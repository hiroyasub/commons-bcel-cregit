begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|statics
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Const
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ClassFormatException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Code
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|CodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Constant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantFieldref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantInterfaceMethodref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantMethodref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantNameAndType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantUtf8
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Deprecated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|DescendingVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|EmptyVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ExceptionTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|InnerClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|InnerClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|JavaClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LineNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LineNumberTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|SourceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Synthetic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Unknown
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ArrayType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ObjectType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|PassVerifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|VerificationResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|Verifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|VerifierFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|AssertionViolatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|ClassConstraintException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|LocalVariableInfoInconsistentException
import|;
end_import

begin_comment
comment|/**  * This PassVerifier verifies a class file according to pass 2 as described in The Java Virtual Machine Specification,  * 2nd edition. More detailed information is to be found at the do_verify() method's documentation.  *  * @see #do_verify()  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|Pass2Verifier
extends|extends
name|PassVerifier
implements|implements
name|Constants
block|{
comment|/**      * A Visitor class that ensures the constant pool satisfies the static constraints. The visitXXX() methods throw      * ClassConstraintException instances otherwise.      *      * @see #constant_pool_entries_satisfy_static_constraints()      */
specifier|private
specifier|final
class|class
name|CPESSC_Visitor
extends|extends
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|EmptyVisitor
block|{
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_Class
decl_stmt|;
comment|/*          * private Class<?> CONST_Fieldref; private Class<?> CONST_Methodref; private Class<?> CONST_InterfaceMethodref;          */
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_String
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_Integer
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_Float
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_Long
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_Double
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_NameAndType
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|CONST_Utf8
decl_stmt|;
specifier|private
specifier|final
name|JavaClass
name|jc
decl_stmt|;
specifier|private
specifier|final
name|ConstantPool
name|cp
decl_stmt|;
comment|// ==jc.getConstantPool() -- only here to save typing work and computing power.
specifier|private
specifier|final
name|int
name|cplen
decl_stmt|;
comment|// == cp.getLength() -- to save computing power.
specifier|private
specifier|final
name|DescendingVisitor
name|carrier
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|field_names
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|field_names_and_desc
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|method_names_and_desc
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|CPESSC_Visitor
parameter_list|(
specifier|final
name|JavaClass
name|jc
parameter_list|)
block|{
name|this
operator|.
name|jc
operator|=
name|jc
expr_stmt|;
name|this
operator|.
name|cp
operator|=
name|jc
operator|.
name|getConstantPool
argument_list|()
expr_stmt|;
name|this
operator|.
name|cplen
operator|=
name|cp
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|this
operator|.
name|CONST_Class
operator|=
name|ConstantClass
operator|.
name|class
expr_stmt|;
comment|/*              * CONST_Fieldref = ConstantFieldref.class; CONST_Methodref = ConstantMethodref.class; CONST_InterfaceMethodref =              * ConstantInterfaceMethodref.class;              */
name|this
operator|.
name|CONST_String
operator|=
name|ConstantString
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|CONST_Integer
operator|=
name|ConstantInteger
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|CONST_Float
operator|=
name|ConstantFloat
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|CONST_Long
operator|=
name|ConstantLong
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|CONST_Double
operator|=
name|ConstantDouble
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|CONST_NameAndType
operator|=
name|ConstantNameAndType
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|CONST_Utf8
operator|=
name|ConstantUtf8
operator|.
name|class
expr_stmt|;
name|this
operator|.
name|carrier
operator|=
operator|new
name|DescendingVisitor
argument_list|(
name|jc
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|carrier
operator|.
name|visit
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|checkIndex
parameter_list|(
specifier|final
name|Node
name|referrer
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|shouldbe
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|cplen
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Invalid index '"
operator|+
name|index
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|referrer
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|Constant
name|c
init|=
name|cp
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shouldbe
operator|.
name|isInstance
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* String isnot = shouldbe.toString().substring(shouldbe.toString().lastIndexOf(".")+1); //Cut all before last "." */
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal constant '"
operator|+
name|tostring
argument_list|(
name|c
argument_list|)
operator|+
literal|"' at index '"
operator|+
name|index
operator|+
literal|"'. '"
operator|+
name|tostring
argument_list|(
name|referrer
argument_list|)
operator|+
literal|"' expects a '"
operator|+
name|shouldbe
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
comment|// SYNTHETIC: see above
comment|// DEPRECATED: see above
comment|/////////////////////////////////////////////////////////
comment|// method_info-structure-ATTRIBUTES (vmspec2 4.6, 4.7) //
comment|/////////////////////////////////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitCode
parameter_list|(
specifier|final
name|Code
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.3
try|try
block|{
comment|// No code attribute allowed for native or abstract methods: see visitMethod(Method).
comment|// Code array constraints are checked in Pass3 (3a and 3b).
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"Code"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'Code' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|carrier
operator|.
name|predecessor
argument_list|()
operator|instanceof
name|Method
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not declared in a method_info structure but in '"
operator|+
name|carrier
operator|.
name|predecessor
argument_list|()
operator|+
literal|"'. Ignored."
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Method
name|m
init|=
operator|(
name|Method
operator|)
name|carrier
operator|.
name|predecessor
argument_list|()
decl_stmt|;
comment|// we can assume this method was visited before;
comment|// i.e. the data consistency was verified.
if|if
condition|(
name|obj
operator|.
name|getCode
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code array of Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|m
operator|+
literal|"') must not be empty."
argument_list|)
throw|;
block|}
comment|// In JustIce, the check for correct offsets into the code array is delayed to Pass 3a.
specifier|final
name|CodeException
index|[]
name|exc_table
init|=
name|obj
operator|.
name|getExceptionTable
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|CodeException
name|element
range|:
name|exc_table
control|)
block|{
specifier|final
name|int
name|exc_index
init|=
name|element
operator|.
name|getCatchType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exc_index
operator|!=
literal|0
condition|)
block|{
comment|// if 0, it catches all Throwables
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|exc_index
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
specifier|final
name|ConstantClass
name|cc
init|=
operator|(
name|ConstantClass
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|exc_index
argument_list|)
decl_stmt|;
comment|// cannot be sure this ConstantClass has already been visited (checked)!
name|checkIndex
argument_list|(
name|cc
argument_list|,
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|cname
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|cname
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|m
operator|+
literal|"') has an exception_table entry '"
operator|+
name|tostring
argument_list|(
name|element
argument_list|)
operator|+
literal|"' that references '"
operator|+
name|cname
operator|+
literal|"' as an Exception but it does not pass verification pass 1: "
operator|+
name|vr
argument_list|)
throw|;
block|}
comment|// We cannot safely trust any other "instanceof" mechanism. We need to transitively verify
comment|// the ancestor hierarchy.
name|JavaClass
name|e
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|cname
argument_list|)
decl_stmt|;
specifier|final
name|JavaClass
name|t
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|Type
operator|.
name|THROWABLE
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|JavaClass
name|o
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|Type
operator|.
name|OBJECT
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|o
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|t
condition|)
block|{
break|break;
comment|// It's a subclass of Throwable, OKAY, leave.
block|}
name|v
operator|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|e
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
name|vr
operator|=
name|v
operator|.
name|doPass1
argument_list|()
expr_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|m
operator|+
literal|"') has an exception_table entry '"
operator|+
name|tostring
argument_list|(
name|element
argument_list|)
operator|+
literal|"' that references '"
operator|+
name|cname
operator|+
literal|"' as an Exception but '"
operator|+
name|e
operator|.
name|getSuperclassName
argument_list|()
operator|+
literal|"' in the ancestor hierachy does not pass verification pass 1: "
operator|+
name|vr
argument_list|)
throw|;
block|}
name|e
operator|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|e
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|t
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|m
operator|+
literal|"') has an exception_table entry '"
operator|+
name|tostring
argument_list|(
name|element
argument_list|)
operator|+
literal|"' that references '"
operator|+
name|cname
operator|+
literal|"' as an Exception but it is not a subclass of '"
operator|+
name|t
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Create object for local variables information
comment|// This is highly unelegant due to usage of the Visitor pattern.
comment|// TODO: rework it.
name|int
name|method_number
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|Method
index|[]
name|ms
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|mn
init|=
literal|0
init|;
name|mn
operator|<
name|ms
operator|.
name|length
condition|;
name|mn
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|==
name|ms
index|[
name|mn
index|]
condition|)
block|{
name|method_number
operator|=
name|mn
expr_stmt|;
break|break;
block|}
block|}
comment|// If the .class file is malformed the loop above may not find a method.
comment|// Try matching names instead of pointers.
if|if
condition|(
name|method_number
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|int
name|mn
init|=
literal|0
init|;
name|mn
operator|<
name|ms
operator|.
name|length
condition|;
name|mn
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|ms
index|[
name|mn
index|]
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|method_number
operator|=
name|mn
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|method_number
operator|<
literal|0
condition|)
block|{
comment|// Mmmmh. Can we be sure BCEL does not sometimes instantiate new objects?
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Could not find a known BCEL Method object in the corresponding BCEL JavaClass object."
argument_list|)
throw|;
block|}
name|localVariablesInfos
index|[
name|method_number
index|]
operator|=
operator|new
name|LocalVariablesInfo
argument_list|(
name|obj
operator|.
name|getMaxLocals
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|num_of_lvt_attribs
init|=
literal|0
decl_stmt|;
comment|// Now iterate through the attributes the Code attribute has.
specifier|final
name|Attribute
index|[]
name|atts
init|=
name|obj
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|att
range|:
name|atts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|att
operator|instanceof
name|LineNumberTable
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|LocalVariableTable
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|m
operator|+
literal|"') is unknown and will therefore be ignored."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// LineNumberTable or LocalVariableTable
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|m
operator|+
literal|"') will effectively be ignored and is only useful for debuggers and such."
argument_list|)
expr_stmt|;
block|}
comment|// LocalVariableTable check (partially delayed to Pass3a).
comment|// Here because its easier to collect the information of the
comment|// (possibly more than one) LocalVariableTables belonging to
comment|// one certain Code attribute.
if|if
condition|(
name|att
operator|instanceof
name|LocalVariableTable
condition|)
block|{
comment|// checks conforming to vmspec2 4.7.9
specifier|final
name|LocalVariableTable
name|lvt
init|=
operator|(
name|LocalVariableTable
operator|)
name|att
decl_stmt|;
name|checkIndex
argument_list|(
name|lvt
argument_list|,
name|lvt
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|lvtname
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|lvt
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lvtname
operator|.
name|equals
argument_list|(
literal|"LocalVariableTable"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The LocalVariableTable attribute '"
operator|+
name|tostring
argument_list|(
name|lvt
argument_list|)
operator|+
literal|"' is not correctly named 'LocalVariableTable' but '"
operator|+
name|lvtname
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// In JustIce, the check for correct offsets into the code array is delayed to Pass 3a.
specifier|final
name|LocalVariable
index|[]
name|localvariables
init|=
name|lvt
operator|.
name|getLocalVariableTable
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|LocalVariable
name|localvariable
range|:
name|localvariables
control|)
block|{
name|checkIndex
argument_list|(
name|lvt
argument_list|,
name|localvariable
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|localname
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|localvariable
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validJavaIdentifier
argument_list|(
name|localname
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"LocalVariableTable '"
operator|+
name|tostring
argument_list|(
name|lvt
argument_list|)
operator|+
literal|"' references a local variable by the name '"
operator|+
name|localname
operator|+
literal|"' which is not a legal Java simple name."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|lvt
argument_list|,
name|localvariable
operator|.
name|getSignatureIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|localsig
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|localvariable
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Local sig.(=descriptor)
name|Type
name|t
decl_stmt|;
try|try
block|{
name|t
operator|=
name|Type
operator|.
name|getType
argument_list|(
name|localsig
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassFormatException
name|cfe
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal descriptor (==signature) '"
operator|+
name|localsig
operator|+
literal|"' used by LocalVariable '"
operator|+
name|tostring
argument_list|(
name|localvariable
argument_list|)
operator|+
literal|"' referenced by '"
operator|+
name|tostring
argument_list|(
name|lvt
argument_list|)
operator|+
literal|"'."
argument_list|,
name|cfe
argument_list|)
throw|;
block|}
specifier|final
name|int
name|localindex
init|=
name|localvariable
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|==
name|Type
operator|.
name|LONG
operator|||
name|t
operator|==
name|Type
operator|.
name|DOUBLE
condition|?
name|localindex
operator|+
literal|1
else|:
name|localindex
operator|)
operator|>=
name|obj
operator|.
name|getMaxLocals
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"LocalVariableTable attribute '"
operator|+
name|tostring
argument_list|(
name|lvt
argument_list|)
operator|+
literal|"' references a LocalVariable '"
operator|+
name|tostring
argument_list|(
name|localvariable
argument_list|)
operator|+
literal|"' with an index that exceeds the surrounding Code attribute's max_locals value of '"
operator|+
name|obj
operator|.
name|getMaxLocals
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
try|try
block|{
name|localVariablesInfos
index|[
name|method_number
index|]
operator|.
name|add
argument_list|(
name|localindex
argument_list|,
name|localname
argument_list|,
name|localvariable
operator|.
name|getStartPC
argument_list|()
argument_list|,
name|localvariable
operator|.
name|getLength
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|LocalVariableInfoInconsistentException
name|lviie
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Conflicting information in LocalVariableTable '"
operator|+
name|tostring
argument_list|(
name|lvt
argument_list|)
operator|+
literal|"' found in Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|tostring
argument_list|(
name|m
argument_list|)
operator|+
literal|"'). "
operator|+
name|lviie
operator|.
name|getMessage
argument_list|()
argument_list|,
name|lviie
argument_list|)
throw|;
block|}
block|}
comment|// for all local variables localvariables[i] in the LocalVariableTable attribute atts[a] END
name|num_of_lvt_attribs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|isStatic
argument_list|()
operator|&&
name|num_of_lvt_attribs
operator|>
name|obj
operator|.
name|getMaxLocals
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Number of LocalVariableTable attributes of Code attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' (method '"
operator|+
name|tostring
argument_list|(
name|m
argument_list|)
operator|+
literal|"') exceeds number of local variable slots '"
operator|+
name|obj
operator|.
name|getMaxLocals
argument_list|()
operator|+
literal|"' ('There may be at most one LocalVariableTable attribute per local variable in the Code attribute.')."
argument_list|)
throw|;
block|}
block|}
comment|// if atts[a] instanceof LocalVariableTable END
block|}
comment|// for all attributes atts[a] END
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// visitCode(Code) END
annotation|@
name|Override
specifier|public
name|void
name|visitCodeException
parameter_list|(
specifier|final
name|CodeException
name|obj
parameter_list|)
block|{
comment|// Code constraints are checked in Pass3 (3a and 3b).
comment|// This does not represent an Attribute but is only
comment|// related to internal BCEL data representation.
comment|// see visitCode(Code)
block|}
comment|/////////////////////////////
comment|// CONSTANTS (vmspec2 4.4) //
comment|/////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitConstantClass
parameter_list|(
specifier|final
name|ConstantClass
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Class
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantDouble
parameter_list|(
specifier|final
name|ConstantDouble
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Double
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// no indices to check
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantFieldref
parameter_list|(
specifier|final
name|ConstantFieldref
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Fieldref
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getClassIndex
argument_list|()
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|,
name|CONST_NameAndType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantFloat
parameter_list|(
specifier|final
name|ConstantFloat
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Float
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// no indices to check
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantInteger
parameter_list|(
specifier|final
name|ConstantInteger
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Integer
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// no indices to check
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantInterfaceMethodref
parameter_list|(
specifier|final
name|ConstantInterfaceMethodref
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_InterfaceMethodref
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getClassIndex
argument_list|()
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|,
name|CONST_NameAndType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantLong
parameter_list|(
specifier|final
name|ConstantLong
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Long
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// no indices to check
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantMethodref
parameter_list|(
specifier|final
name|ConstantMethodref
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Methodref
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getClassIndex
argument_list|()
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|,
name|CONST_NameAndType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantNameAndType
parameter_list|(
specifier|final
name|ConstantNameAndType
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_NameAndType
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
comment|// checkIndex(obj, obj.getDescriptorIndex(), CONST_Utf8); //inconsistently named in BCEL, see below.
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getSignatureIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantPool
parameter_list|(
specifier|final
name|ConstantPool
name|obj
parameter_list|)
block|{
comment|// No need to. We're piggybacked by the DescendingVisitor.
comment|// This does not represent an Attribute but is only
comment|// related to internal BCEL data representation.
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantString
parameter_list|(
specifier|final
name|ConstantString
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_String
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getStringIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantUtf8
parameter_list|(
specifier|final
name|ConstantUtf8
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Utf8
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Wrong constant tag in '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// no indices to check
block|}
comment|////////////////////////////////////////////////////////
comment|// field_info-structure-ATTRIBUTES (vmspec2 4.5, 4.7) //
comment|////////////////////////////////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitConstantValue
parameter_list|(
specifier|final
name|ConstantValue
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.2
comment|// Despite its name, this really is an Attribute,
comment|// not a constant!
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"ConstantValue"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The ConstantValue attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'ConstantValue' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|Object
name|pred
init|=
name|carrier
operator|.
name|predecessor
argument_list|()
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|Field
condition|)
block|{
comment|// ConstantValue attributes are quite senseless if the predecessor is not a field.
specifier|final
name|Field
name|f
init|=
operator|(
name|Field
operator|)
name|pred
decl_stmt|;
comment|// Field constraints have been checked before -- so we are safe using their type information.
specifier|final
name|Type
name|fieldType
init|=
name|Type
operator|.
name|getType
argument_list|(
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|f
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|obj
operator|.
name|getConstantValueIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|cplen
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Invalid index '"
operator|+
name|index
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|Constant
name|c
init|=
name|cp
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONST_Long
operator|.
name|isInstance
argument_list|(
name|c
argument_list|)
operator|&&
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|LONG
argument_list|)
operator|||
name|CONST_Float
operator|.
name|isInstance
argument_list|(
name|c
argument_list|)
operator|&&
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|FLOAT
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|CONST_Double
operator|.
name|isInstance
argument_list|(
name|c
argument_list|)
operator|&&
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|DOUBLE
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|CONST_Integer
operator|.
name|isInstance
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|INT
argument_list|)
operator|||
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|SHORT
argument_list|)
operator|||
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|CHAR
argument_list|)
operator|||
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|BYTE
argument_list|)
operator|||
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|BOOLEAN
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|CONST_String
operator|.
name|isInstance
argument_list|(
name|c
argument_list|)
operator|&&
name|fieldType
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|STRING
argument_list|)
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal type of ConstantValue '"
operator|+
name|obj
operator|+
literal|"' embedding Constant '"
operator|+
name|c
operator|+
literal|"'. It is referenced by field '"
operator|+
name|tostring
argument_list|(
name|f
argument_list|)
operator|+
literal|"' expecting a different type: '"
operator|+
name|fieldType
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitDeprecated
parameter_list|(
specifier|final
name|Deprecated
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.10
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"Deprecated"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The Deprecated attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'Deprecated' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitExceptionTable
parameter_list|(
specifier|final
name|ExceptionTable
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.4
try|try
block|{
comment|// incorrectly named, it's the Exceptions attribute (vmspec2 4.7.4)
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"Exceptions"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The Exceptions attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'Exceptions' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|int
index|[]
name|exc_indices
init|=
name|obj
operator|.
name|getExceptionIndexTable
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|exc_indice
range|:
name|exc_indices
control|)
block|{
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|exc_indice
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
specifier|final
name|ConstantClass
name|cc
init|=
operator|(
name|ConstantClass
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|exc_indice
argument_list|)
decl_stmt|;
name|checkIndex
argument_list|(
name|cc
argument_list|,
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
comment|// can't be sure this ConstantClass has already been visited (checked)!
comment|// convert internal notation on-the-fly to external notation:
specifier|final
name|String
name|cname
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|cname
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Exceptions attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' references '"
operator|+
name|cname
operator|+
literal|"' as an Exception but it does not pass verification pass 1: "
operator|+
name|vr
argument_list|)
throw|;
block|}
comment|// We cannot safely trust any other "instanceof" mechanism. We need to transitively verify
comment|// the ancestor hierarchy.
name|JavaClass
name|e
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|cname
argument_list|)
decl_stmt|;
specifier|final
name|JavaClass
name|t
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|Type
operator|.
name|THROWABLE
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|JavaClass
name|o
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|Type
operator|.
name|OBJECT
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|e
operator|!=
name|o
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|t
condition|)
block|{
break|break;
comment|// It's a subclass of Throwable, OKAY, leave.
block|}
name|v
operator|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|e
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
name|vr
operator|=
name|v
operator|.
name|doPass1
argument_list|()
expr_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Exceptions attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' references '"
operator|+
name|cname
operator|+
literal|"' as an Exception but '"
operator|+
name|e
operator|.
name|getSuperclassName
argument_list|()
operator|+
literal|"' in the ancestor hierachy does not pass verification pass 1: "
operator|+
name|vr
argument_list|)
throw|;
block|}
name|e
operator|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|e
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
name|t
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Exceptions attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' references '"
operator|+
name|cname
operator|+
literal|"' as an Exception but it is not a subclass of '"
operator|+
name|t
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|//////////////////////////
comment|// FIELDS (vmspec2 4.5) //
comment|//////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitField
parameter_list|(
specifier|final
name|Field
name|obj
parameter_list|)
block|{
if|if
condition|(
name|jc
operator|.
name|isClass
argument_list|()
condition|)
block|{
name|int
name|maxone
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj
operator|.
name|isPrivate
argument_list|()
condition|)
block|{
name|maxone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|.
name|isProtected
argument_list|()
condition|)
block|{
name|maxone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|.
name|isPublic
argument_list|()
condition|)
block|{
name|maxone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|maxone
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isFinal
argument_list|()
operator|&&
name|obj
operator|.
name|isVolatile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must only have at most one of its ACC_FINAL, ACC_VOLATILE modifiers set."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// isInterface!
if|if
condition|(
operator|!
name|obj
operator|.
name|isPublic
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have the ACC_PUBLIC modifier set but hasn't!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|obj
operator|.
name|isStatic
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have the ACC_STATIC modifier set but hasn't!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|obj
operator|.
name|isFinal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have the ACC_FINAL modifier set but hasn't!"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|obj
operator|.
name|getAccessFlags
argument_list|()
operator|&
operator|~
operator|(
name|Const
operator|.
name|ACC_PUBLIC
operator||
name|Const
operator|.
name|ACC_PRIVATE
operator||
name|Const
operator|.
name|ACC_PROTECTED
operator||
name|Const
operator|.
name|ACC_STATIC
operator||
name|Const
operator|.
name|ACC_FINAL
operator||
name|Const
operator|.
name|ACC_VOLATILE
operator||
name|Const
operator|.
name|ACC_TRANSIENT
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
name|addMessage
argument_list|(
literal|"Field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has access flag(s) other than ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,"
operator|+
literal|" ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT set (ignored)."
argument_list|)
expr_stmt|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
name|obj
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validFieldName
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has illegal name '"
operator|+
name|obj
operator|.
name|getName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// A descriptor is often named signature in BCEL
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getSignatureIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sig
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method sig.(=descriptor)
try|try
block|{
name|Type
operator|.
name|getType
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* Don't need the return value */
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassFormatException
name|cfe
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal descriptor (==signature) '"
operator|+
name|sig
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|,
name|cfe
argument_list|)
throw|;
block|}
specifier|final
name|String
name|nameanddesc
init|=
name|name
operator|+
name|sig
decl_stmt|;
if|if
condition|(
name|field_names_and_desc
operator|.
name|contains
argument_list|(
name|nameanddesc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"No two fields (like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"') are allowed have same names and descriptors!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|field_names
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"More than one field of name '"
operator|+
name|name
operator|+
literal|"' detected (but with different type descriptors). This is very unusual."
argument_list|)
expr_stmt|;
block|}
name|field_names_and_desc
operator|.
name|add
argument_list|(
name|nameanddesc
argument_list|)
expr_stmt|;
name|field_names
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
specifier|final
name|Attribute
index|[]
name|atts
init|=
name|obj
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|att
range|:
name|atts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|att
operator|instanceof
name|ConstantValue
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|Synthetic
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|Deprecated
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of Field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is unknown and will therefore be ignored."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|att
operator|instanceof
name|ConstantValue
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of Field '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not a ConstantValue and is therefore only of use for debuggers and such."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitInnerClass
parameter_list|(
specifier|final
name|InnerClass
name|obj
parameter_list|)
block|{
comment|// This does not represent an Attribute but is only
comment|// related to internal BCEL data representation.
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitInnerClasses
parameter_list|(
specifier|final
name|InnerClasses
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.5
comment|// exactly one InnerClasses attr per ClassFile if some inner class is refernced: see visitJavaClass()
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"InnerClasses"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The InnerClasses attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'InnerClasses' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|InnerClass
index|[]
name|ics
init|=
name|obj
operator|.
name|getInnerClasses
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|InnerClass
name|ic
range|:
name|ics
control|)
block|{
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|ic
operator|.
name|getInnerClassIndex
argument_list|()
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
specifier|final
name|int
name|outer_idx
init|=
name|ic
operator|.
name|getOuterClassIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|outer_idx
operator|!=
literal|0
condition|)
block|{
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|outer_idx
argument_list|,
name|CONST_Class
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|innername_idx
init|=
name|ic
operator|.
name|getInnerNameIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|innername_idx
operator|!=
literal|0
condition|)
block|{
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|innername_idx
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
block|}
name|int
name|acc
init|=
name|ic
operator|.
name|getInnerAccessFlags
argument_list|()
decl_stmt|;
name|acc
operator|=
name|acc
operator|&
operator|~
operator|(
name|Const
operator|.
name|ACC_PUBLIC
operator||
name|Const
operator|.
name|ACC_PRIVATE
operator||
name|Const
operator|.
name|ACC_PROTECTED
operator||
name|Const
operator|.
name|ACC_STATIC
operator||
name|Const
operator|.
name|ACC_FINAL
operator||
name|Const
operator|.
name|ACC_INTERFACE
operator||
name|Const
operator|.
name|ACC_ABSTRACT
operator|)
expr_stmt|;
if|if
condition|(
name|acc
operator|!=
literal|0
condition|)
block|{
name|addMessage
argument_list|(
literal|"Unknown access flag for inner class '"
operator|+
name|tostring
argument_list|(
name|ic
argument_list|)
operator|+
literal|"' set (InnerClasses attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"')."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Semantical consistency is not yet checked by Sun, see vmspec2 4.7.5.
comment|// [marked TODO in JustIce]
block|}
comment|///////////////////////////////////////
comment|// ClassFile structure (vmspec2 4.1) //
comment|///////////////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitJavaClass
parameter_list|(
specifier|final
name|JavaClass
name|obj
parameter_list|)
block|{
specifier|final
name|Attribute
index|[]
name|atts
init|=
name|obj
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|boolean
name|foundSourceFile
init|=
literal|false
decl_stmt|;
name|boolean
name|foundInnerClasses
init|=
literal|false
decl_stmt|;
comment|// Is there an InnerClass referenced?
comment|// This is a costly check; existing verifiers don't do it!
specifier|final
name|boolean
name|hasInnerClass
init|=
operator|new
name|InnerClassDetector
argument_list|(
name|jc
argument_list|)
operator|.
name|innerClassReferenced
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|att
range|:
name|atts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|att
operator|instanceof
name|SourceFile
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|Deprecated
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|InnerClasses
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|Synthetic
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of the ClassFile structure '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is unknown and will therefore be ignored."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|att
operator|instanceof
name|SourceFile
condition|)
block|{
if|if
condition|(
name|foundSourceFile
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"A ClassFile structure (like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"') may have no more than one SourceFile attribute."
argument_list|)
throw|;
comment|// vmspec2 4.7.7
block|}
name|foundSourceFile
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|att
operator|instanceof
name|InnerClasses
condition|)
block|{
if|if
condition|(
operator|!
name|foundInnerClasses
condition|)
block|{
name|foundInnerClasses
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|hasInnerClass
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"A Classfile structure (like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"') must have exactly one InnerClasses attribute"
operator|+
literal|" if at least one Inner Class is referenced (which is the case)."
operator|+
literal|" More than one InnerClasses attribute was found."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|hasInnerClass
condition|)
block|{
name|addMessage
argument_list|(
literal|"No referenced Inner Class found, but InnerClasses attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' found. Strongly suggest removal of that attribute."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hasInnerClass
operator|&&
operator|!
name|foundInnerClasses
condition|)
block|{
comment|// throw new ClassConstraintException("A Classfile structure (like '"+tostring(obj)+
comment|// "') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case)."+
comment|// " No InnerClasses attribute was found.");
comment|// vmspec2, page 125 says it would be a constraint: but existing verifiers
comment|// don't check it and javac doesn't satisfy it when it comes to anonymous
comment|// inner classes
name|addMessage
argument_list|(
literal|"A Classfile structure (like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"') must have exactly one InnerClasses attribute if at least one Inner Class is referenced (which is the case)."
operator|+
literal|" No InnerClasses attribute was found."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitLineNumber
parameter_list|(
specifier|final
name|LineNumber
name|obj
parameter_list|)
block|{
comment|// This does not represent an Attribute but is only
comment|// related to internal BCEL data representation.
comment|// see visitLineNumberTable(LineNumberTable)
block|}
comment|// SYNTHETIC: see above
comment|// DEPRECATED: see above
comment|//////////////////////////////////////////////////////////////
comment|// code_attribute-structure-ATTRIBUTES (vmspec2 4.7.3, 4.7) //
comment|//////////////////////////////////////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitLineNumberTable
parameter_list|(
specifier|final
name|LineNumberTable
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.8
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"LineNumberTable"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The LineNumberTable attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'LineNumberTable' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// In JustIce,this check is delayed to Pass 3a.
comment|// LineNumber[] linenumbers = obj.getLineNumberTable();
comment|// ...validity check...
block|}
comment|//////////
comment|// BCEL //
comment|//////////
annotation|@
name|Override
specifier|public
name|void
name|visitLocalVariable
parameter_list|(
specifier|final
name|LocalVariable
name|obj
parameter_list|)
block|{
comment|// This does not represent an Attribute but is only
comment|// related to internal BCEL data representation.
comment|// see visitLocalVariableTable(LocalVariableTable)
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitLocalVariableTable
parameter_list|(
specifier|final
name|LocalVariableTable
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.9
comment|// In JustIce,this check is partially delayed to Pass 3a.
comment|// The other part can be found in the visitCode(Code) method.
block|}
comment|///////////////////////////
comment|// METHODS (vmspec2 4.6) //
comment|///////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitMethod
parameter_list|(
specifier|final
name|Method
name|obj
parameter_list|)
block|{
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
name|obj
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validMethodName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has illegal name '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// A descriptor is often named signature in BCEL
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getSignatureIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sig
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Method's signature(=descriptor)
name|Type
name|t
decl_stmt|;
name|Type
index|[]
name|ts
decl_stmt|;
comment|// needed below the try block.
try|try
block|{
name|t
operator|=
name|Type
operator|.
name|getReturnType
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|ts
operator|=
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassFormatException
name|cfe
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal descriptor (==signature) '"
operator|+
name|sig
operator|+
literal|"' used by Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|,
name|cfe
argument_list|)
throw|;
block|}
comment|// Check if referenced objects exist.
name|Type
name|act
init|=
name|t
decl_stmt|;
if|if
condition|(
name|act
operator|instanceof
name|ArrayType
condition|)
block|{
name|act
operator|=
operator|(
operator|(
name|ArrayType
operator|)
name|act
operator|)
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|instanceof
name|ObjectType
condition|)
block|{
specifier|final
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|act
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has a return type that does not pass verification pass 1: '"
operator|+
name|vr
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
for|for
control|(
specifier|final
name|Type
name|element
range|:
name|ts
control|)
block|{
name|act
operator|=
name|element
expr_stmt|;
if|if
condition|(
name|act
operator|instanceof
name|ArrayType
condition|)
block|{
name|act
operator|=
operator|(
operator|(
name|ArrayType
operator|)
name|act
operator|)
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|instanceof
name|ObjectType
condition|)
block|{
specifier|final
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|act
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has an argument type that does not pass verification pass 1: '"
operator|+
name|vr
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Nearly forgot this! Funny return values are allowed, but a non-empty arguments list makes a different method out of
comment|// it!
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
operator|&&
name|ts
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has illegal name '"
operator|+
name|name
operator|+
literal|"'."
operator|+
literal|" Its name resembles the class or interface initialization method"
operator|+
literal|" which it isn't because of its arguments (==descriptor)."
argument_list|)
throw|;
block|}
if|if
condition|(
name|jc
operator|.
name|isClass
argument_list|()
condition|)
block|{
name|int
name|maxone
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj
operator|.
name|isPrivate
argument_list|()
condition|)
block|{
name|maxone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|.
name|isProtected
argument_list|()
condition|)
block|{
name|maxone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|.
name|isPublic
argument_list|()
condition|)
block|{
name|maxone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|maxone
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must only have at most one of its ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC modifiers set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isAbstract
argument_list|()
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|isFinal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Abstract method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have the ACC_FINAL modifier set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Abstract method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have the ACC_NATIVE modifier set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isPrivate
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Abstract method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have the ACC_PRIVATE modifier set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isStatic
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Abstract method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have the ACC_STATIC modifier set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isStrictfp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Abstract method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have the ACC_STRICT modifier set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isSynchronized
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Abstract method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have the ACC_SYNCHRONIZED modifier set."
argument_list|)
throw|;
block|}
block|}
comment|// A specific instance initialization method... (vmspec2,Page 116).
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
condition|)
block|{
comment|// ..may have at most one of ACC_PRIVATE, ACC_PROTECTED, ACC_PUBLIC set: is checked above.
comment|// ..may also have ACC_STRICT set, but none of the other flags in table 4.5 (vmspec2, page 115)
if|if
condition|(
name|obj
operator|.
name|isStatic
argument_list|()
operator|||
name|obj
operator|.
name|isFinal
argument_list|()
operator|||
name|obj
operator|.
name|isSynchronized
argument_list|()
operator|||
name|obj
operator|.
name|isNative
argument_list|()
operator|||
name|obj
operator|.
name|isAbstract
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Instance initialization method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have"
operator|+
literal|" any of the ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT modifiers set."
argument_list|)
throw|;
block|}
block|}
block|}
if|else if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
condition|)
block|{
comment|// vmspec2, p.116, 2nd paragraph
if|if
condition|(
name|jc
operator|.
name|getMajor
argument_list|()
operator|>=
name|Const
operator|.
name|MAJOR_1_8
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|.
name|isPublic
argument_list|()
operator|^
name|obj
operator|.
name|isPrivate
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have"
operator|+
literal|" exactly one of its ACC_PUBLIC and ACC_PRIVATE modifiers set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isProtected
argument_list|()
operator|||
name|obj
operator|.
name|isFinal
argument_list|()
operator|||
name|obj
operator|.
name|isSynchronized
argument_list|()
operator|||
name|obj
operator|.
name|isNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have"
operator|+
literal|" any of the ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, or ACC_NATIVE modifiers set."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|obj
operator|.
name|isPublic
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have the ACC_PUBLIC modifier set but hasn't!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|obj
operator|.
name|isAbstract
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have the ACC_ABSTRACT modifier set but hasn't!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|obj
operator|.
name|isPrivate
argument_list|()
operator|||
name|obj
operator|.
name|isProtected
argument_list|()
operator|||
name|obj
operator|.
name|isStatic
argument_list|()
operator|||
name|obj
operator|.
name|isFinal
argument_list|()
operator|||
name|obj
operator|.
name|isSynchronized
argument_list|()
operator|||
name|obj
operator|.
name|isNative
argument_list|()
operator|||
name|obj
operator|.
name|isStrictfp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Interface method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have"
operator|+
literal|" any of the ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED,"
operator|+
literal|" ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT modifiers set."
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|obj
operator|.
name|getAccessFlags
argument_list|()
operator|&
operator|~
operator|(
name|Const
operator|.
name|ACC_PUBLIC
operator||
name|Const
operator|.
name|ACC_PRIVATE
operator||
name|Const
operator|.
name|ACC_PROTECTED
operator||
name|Const
operator|.
name|ACC_STATIC
operator||
name|Const
operator|.
name|ACC_FINAL
operator||
name|Const
operator|.
name|ACC_SYNCHRONIZED
operator||
name|Const
operator|.
name|ACC_NATIVE
operator||
name|Const
operator|.
name|ACC_ABSTRACT
operator||
name|Const
operator|.
name|ACC_STRICT
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
name|addMessage
argument_list|(
literal|"Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has access flag(s) other than"
operator|+
literal|" ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,"
operator|+
literal|" ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT set (ignored)."
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
name|nameanddesc
init|=
name|name
operator|+
name|sig
decl_stmt|;
if|if
condition|(
name|method_names_and_desc
operator|.
name|contains
argument_list|(
name|nameanddesc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"No two methods (like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"') are allowed have same names and desciptors!"
argument_list|)
throw|;
block|}
name|method_names_and_desc
operator|.
name|add
argument_list|(
name|nameanddesc
argument_list|)
expr_stmt|;
specifier|final
name|Attribute
index|[]
name|atts
init|=
name|obj
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
name|int
name|num_code_atts
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|att
range|:
name|atts
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|att
operator|instanceof
name|Code
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|ExceptionTable
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|Synthetic
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|Deprecated
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is unknown and will therefore be ignored."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|att
operator|instanceof
name|Code
operator|)
operator|&&
operator|!
operator|(
name|att
operator|instanceof
name|ExceptionTable
operator|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"Attribute '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"' as an attribute of Method '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is neither Code nor Exceptions and is therefore only of use for debuggers and such."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|att
operator|instanceof
name|Code
operator|&&
operator|(
name|obj
operator|.
name|isNative
argument_list|()
operator|||
name|obj
operator|.
name|isAbstract
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Native or abstract methods like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must not have a Code attribute like '"
operator|+
name|tostring
argument_list|(
name|att
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
comment|// vmspec2
comment|// page120,
comment|// 4.7.3
block|}
if|if
condition|(
name|att
operator|instanceof
name|Code
condition|)
block|{
name|num_code_atts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|obj
operator|.
name|isNative
argument_list|()
operator|&&
operator|!
name|obj
operator|.
name|isAbstract
argument_list|()
operator|&&
name|num_code_atts
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Non-native, non-abstract methods like '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' must have exactly one Code attribute (found: "
operator|+
name|num_code_atts
operator|+
literal|")."
argument_list|)
throw|;
block|}
block|}
comment|///////////////////////////////////////////////////////
comment|// ClassFile-structure-ATTRIBUTES (vmspec2 4.1, 4.7) //
comment|///////////////////////////////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitSourceFile
parameter_list|(
specifier|final
name|SourceFile
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.7
comment|// zero or one SourceFile attr per ClassFile: see visitJavaClass()
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"SourceFile"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The SourceFile attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'SourceFile' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getSourceFileIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sourceFileName
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getSourceFileIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// ==obj.getSourceFileName() ?
specifier|final
name|String
name|sourceFileNameLc
init|=
name|sourceFileName
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceFileName
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|sourceFileName
operator|.
name|indexOf
argument_list|(
literal|'\\'
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|sourceFileName
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|sourceFileNameLc
operator|.
name|lastIndexOf
argument_list|(
literal|".java"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|addMessage
argument_list|(
literal|"SourceFile attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has a funny name: remember not to confuse certain parsers working on javap's output. Also, this name ('"
operator|+
name|sourceFileName
operator|+
literal|"') is considered an unqualified (simple) file name only."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitSynthetic
parameter_list|(
specifier|final
name|Synthetic
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.6
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
literal|"Synthetic"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"The Synthetic attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' is not correctly named 'Synthetic' but '"
operator|+
name|name
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
comment|////////////////////////////////////////////////////
comment|// MISC-structure-ATTRIBUTES (vmspec2 4.7.1, 4.7) //
comment|////////////////////////////////////////////////////
annotation|@
name|Override
specifier|public
name|void
name|visitUnknown
parameter_list|(
specifier|final
name|Unknown
name|obj
parameter_list|)
block|{
comment|// vmspec2 4.7.1
comment|// Represents an unknown attribute.
name|checkIndex
argument_list|(
name|obj
argument_list|,
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|,
name|CONST_Utf8
argument_list|)
expr_stmt|;
comment|// Maybe only misnamed? Give a (warning) message.
name|addMessage
argument_list|(
literal|"Unknown attribute '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'. This attribute is not known in any context!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * A Visitor class that ensures the ConstantCP-subclassed entries of the constant pool are valid.<B>Precondition:      * index-style cross referencing in the constant pool must be valid.</B>      *      * @see #constant_pool_entries_satisfy_static_constraints()      * @see org.apache.bcel.classfile.ConstantCP      */
specifier|private
specifier|final
class|class
name|FAMRAV_Visitor
extends|extends
name|EmptyVisitor
block|{
specifier|private
specifier|final
name|ConstantPool
name|cp
decl_stmt|;
comment|// ==jc.getConstantPool() -- only here to save typing work.
specifier|private
name|FAMRAV_Visitor
parameter_list|(
specifier|final
name|JavaClass
name|jc
parameter_list|)
block|{
name|this
operator|.
name|cp
operator|=
name|jc
operator|.
name|getConstantPool
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantFieldref
parameter_list|(
specifier|final
name|ConstantFieldref
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Fieldref
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"ConstantFieldref '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has wrong tag!"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|nameAndTypeIndex
init|=
name|obj
operator|.
name|getNameAndTypeIndex
argument_list|()
decl_stmt|;
specifier|final
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|nameAndTypeIndex
argument_list|)
decl_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method name
if|if
condition|(
operator|!
name|validFieldName
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Invalid field name '"
operator|+
name|name
operator|+
literal|"' referenced by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|int
name|classIndex
init|=
name|obj
operator|.
name|getClassIndex
argument_list|()
decl_stmt|;
specifier|final
name|ConstantClass
name|cc
init|=
operator|(
name|ConstantClass
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|classIndex
argument_list|)
decl_stmt|;
specifier|final
name|String
name|className
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Class Name in internal form
if|if
condition|(
operator|!
name|validClassName
argument_list|(
name|className
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal class name '"
operator|+
name|className
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|String
name|sig
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method sig.(=descriptor)
try|try
block|{
name|Type
operator|.
name|getType
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* Don't need the return value */
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassFormatException
name|cfe
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal descriptor (==signature) '"
operator|+
name|sig
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|,
name|cfe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantInterfaceMethodref
parameter_list|(
specifier|final
name|ConstantInterfaceMethodref
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_InterfaceMethodref
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"ConstantInterfaceMethodref '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has wrong tag!"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|nameAndTypeIndex
init|=
name|obj
operator|.
name|getNameAndTypeIndex
argument_list|()
decl_stmt|;
specifier|final
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|nameAndTypeIndex
argument_list|)
decl_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method name
if|if
condition|(
operator|!
name|validInterfaceMethodName
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Invalid (interface) method name '"
operator|+
name|name
operator|+
literal|"' referenced by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|int
name|classIndex
init|=
name|obj
operator|.
name|getClassIndex
argument_list|()
decl_stmt|;
specifier|final
name|ConstantClass
name|cc
init|=
operator|(
name|ConstantClass
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|classIndex
argument_list|)
decl_stmt|;
specifier|final
name|String
name|className
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Class Name in internal form
if|if
condition|(
operator|!
name|validClassName
argument_list|(
name|className
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal class name '"
operator|+
name|className
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|String
name|sig
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method sig.(=descriptor)
try|try
block|{
specifier|final
name|Type
name|t
init|=
name|Type
operator|.
name|getReturnType
argument_list|(
name|sig
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
operator|&&
name|t
operator|!=
name|Type
operator|.
name|VOID
condition|)
block|{
name|addMessage
argument_list|(
literal|"Class or interface initialization method '"
operator|+
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
operator|+
literal|"' usually has VOID return type instead of '"
operator|+
name|t
operator|+
literal|"'. Note this is really not a requirement of The Java Virtual Machine Specification, Second Edition."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassFormatException
name|cfe
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal descriptor (==signature) '"
operator|+
name|sig
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|,
name|cfe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visitConstantMethodref
parameter_list|(
specifier|final
name|ConstantMethodref
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|.
name|getTag
argument_list|()
operator|!=
name|Const
operator|.
name|CONSTANT_Methodref
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"ConstantMethodref '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"' has wrong tag!"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|nameAndTypeIndex
init|=
name|obj
operator|.
name|getNameAndTypeIndex
argument_list|()
decl_stmt|;
specifier|final
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|nameAndTypeIndex
argument_list|)
decl_stmt|;
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method name
if|if
condition|(
operator|!
name|validClassMethodName
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Invalid (non-interface) method name '"
operator|+
name|name
operator|+
literal|"' referenced by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|int
name|classIndex
init|=
name|obj
operator|.
name|getClassIndex
argument_list|()
decl_stmt|;
specifier|final
name|ConstantClass
name|cc
init|=
operator|(
name|ConstantClass
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|classIndex
argument_list|)
decl_stmt|;
specifier|final
name|String
name|className
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cc
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Class Name in internal form
if|if
condition|(
operator|!
name|validClassName
argument_list|(
name|className
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal class name '"
operator|+
name|className
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|)
throw|;
block|}
specifier|final
name|String
name|sig
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|cp
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getSignatureIndex
argument_list|()
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
comment|// Field or Method sig.(=descriptor)
try|try
block|{
specifier|final
name|Type
name|t
init|=
name|Type
operator|.
name|getReturnType
argument_list|(
name|sig
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|&&
name|t
operator|!=
name|Type
operator|.
name|VOID
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Instance initialization method must have VOID return type."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassFormatException
name|cfe
parameter_list|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Illegal descriptor (==signature) '"
operator|+
name|sig
operator|+
literal|"' used by '"
operator|+
name|tostring
argument_list|(
name|obj
argument_list|)
operator|+
literal|"'."
argument_list|,
name|cfe
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * This class serves for finding out if a given JavaClass' ConstantPool references an Inner Class. The Java Virtual      * Machine Specification, Second Edition is not very precise about when an "InnerClasses" attribute has to appear.      * However, it states that there has to be exactly one InnerClasses attribute in the ClassFile structure if the constant      * pool of a class or interface refers to any class or interface "that is not a member of a package". Sun does not mean      * "member of the default package". In "Inner Classes Specification" they point out how a "bytecode name" is derived so      * one has to deduce what a class name of a class "that is not a member of a package" looks like: there is at least one      * character in the byte- code name that cannot be part of a legal Java Language Class name (and not equal to '/'). This      * assumption is wrong as the delimiter is '$' for which Character.isJavaIdentifierPart() == true. Hence, you really run      * into trouble if you have a toplevel class called "A$XXX" and another toplevel class called "A" with in inner class      * called "XXX". JustIce cannot repair this; please note that existing verifiers at this time even fail to detect      * missing InnerClasses attributes in pass 2.      */
specifier|private
specifier|static
class|class
name|InnerClassDetector
extends|extends
name|EmptyVisitor
block|{
specifier|private
name|boolean
name|hasInnerClass
decl_stmt|;
specifier|private
specifier|final
name|JavaClass
name|jc
decl_stmt|;
specifier|private
specifier|final
name|ConstantPool
name|cp
decl_stmt|;
comment|/** Constructs an InnerClassDetector working on the JavaClass _jc. */
specifier|public
name|InnerClassDetector
parameter_list|(
specifier|final
name|JavaClass
name|javaClass
parameter_list|)
block|{
name|this
operator|.
name|jc
operator|=
name|javaClass
expr_stmt|;
name|this
operator|.
name|cp
operator|=
name|jc
operator|.
name|getConstantPool
argument_list|()
expr_stmt|;
operator|new
name|DescendingVisitor
argument_list|(
name|jc
argument_list|,
name|this
argument_list|)
operator|.
name|visit
argument_list|()
expr_stmt|;
block|}
comment|/**          * Returns if the JavaClass this InnerClassDetector is working on has an Inner Class reference in its constant pool.          *          * @return Whether this InnerClassDetector is working on has an Inner Class reference in its constant pool.          */
specifier|public
name|boolean
name|innerClassReferenced
parameter_list|()
block|{
return|return
name|hasInnerClass
return|;
block|}
comment|/** This method casually visits ConstantClass references. */
annotation|@
name|Override
specifier|public
name|void
name|visitConstantClass
parameter_list|(
specifier|final
name|ConstantClass
name|obj
parameter_list|)
block|{
specifier|final
name|Constant
name|c
init|=
name|cp
operator|.
name|getConstant
argument_list|(
name|obj
operator|.
name|getNameIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|ConstantUtf8
condition|)
block|{
comment|// Ignore the case where it's not a ConstantUtf8 here, we'll find out later.
specifier|final
name|String
name|classname
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
name|c
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|classname
operator|.
name|startsWith
argument_list|(
name|jc
operator|.
name|getClassName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|"$"
argument_list|)
condition|)
block|{
name|hasInnerClass
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This method is here to save typing work and improve code readability.      */
specifier|private
specifier|static
name|String
name|tostring
parameter_list|(
specifier|final
name|Node
name|n
parameter_list|)
block|{
return|return
operator|new
name|StringRepresentation
argument_list|(
name|n
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid method name that may be referenced by      * ConstantMethodref objects.      */
specifier|private
specifier|static
name|boolean
name|validClassMethodName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|validMethodName
argument_list|(
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid Java class name.      */
specifier|private
specifier|static
name|boolean
name|validClassName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
comment|/*          * TODO: implement. Are there any restrictions?          */
return|return
literal|true
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid Java field name.      */
specifier|private
specifier|static
name|boolean
name|validFieldName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
comment|// vmspec2 2.7, vmspec2 2.2
return|return
name|validJavaIdentifier
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid Java interface method name that may be      * referenced by ConstantInterfaceMethodref objects.      */
specifier|private
specifier|static
name|boolean
name|validInterfaceMethodName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
comment|// I guess we should assume special names forbidden here.
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|validJavaLangMethodName
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid Java identifier (so-called simple or      * unqualified name).      */
specifier|private
specifier|static
name|boolean
name|validJavaIdentifier
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
comment|// vmspec2 2.7, vmspec2 2.2
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid Java programming language method name      * stored as a simple (non-qualified) name. Conforming to: The Java Virtual Machine Specification, Second Edition,      * 2.7, 2.7.1, 2.2.      */
specifier|private
specifier|static
name|boolean
name|validJavaLangMethodName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|validJavaIdentifier
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * This method returns true if and only if the supplied String represents a valid method name. This is basically the      * same as a valid identifier name in the Java programming language, but the special name for the instance      * initialization method is allowed and the special name for the class/interface initialization method may be allowed.      */
specifier|private
specifier|static
name|boolean
name|validMethodName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|boolean
name|allowStaticInit
parameter_list|)
block|{
if|if
condition|(
name|validJavaLangMethodName
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|allowStaticInit
condition|)
block|{
return|return
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
return|;
block|}
return|return
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
return|;
block|}
comment|/**      * The LocalVariableInfo instances used by Pass3bVerifier. localVariablesInfos[i] denotes the information for the local      * variables of method number i in the JavaClass this verifier operates on.      */
specifier|private
name|LocalVariablesInfo
index|[]
name|localVariablesInfos
decl_stmt|;
comment|/** The Verifier that created this. */
specifier|private
specifier|final
name|Verifier
name|myOwner
decl_stmt|;
comment|/**      * Should only be instantiated by a Verifier.      *      * @see Verifier      */
specifier|public
name|Pass2Verifier
parameter_list|(
specifier|final
name|Verifier
name|owner
parameter_list|)
block|{
name|myOwner
operator|=
name|owner
expr_stmt|;
block|}
comment|/**      * Ensures that the constant pool entries satisfy the static constraints as described in The Java Virtual Machine      * Specification, 2nd Edition.      *      * @throws ClassConstraintException otherwise.      */
specifier|private
name|void
name|constant_pool_entries_satisfy_static_constraints
parameter_list|()
block|{
try|try
block|{
comment|// Most of the consistency is handled internally by BCEL; here
comment|// we only have to verify if the indices of the constants point
comment|// to constants of the appropriate type and such.
specifier|final
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
operator|new
name|CPESSC_Visitor
argument_list|(
name|jc
argument_list|)
expr_stmt|;
comment|// constructor implicitly traverses jc
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Pass 2 is the pass where static properties of the class file are checked without looking into "Code" arrays of      * methods. This verification pass is usually invoked when a class is resolved; and it may be possible that this      * verification pass has to load in other classes such as superclasses or implemented interfaces. Therefore, Pass 1 is      * run on them.<BR>      * Note that most referenced classes are<B>not</B> loaded in for verification or for an existance check by this pass;      * only the syntactical correctness of their names and descriptors (a.k.a. signatures) is checked.<BR>      * Very few checks that conceptually belong here are delayed until pass 3a in JustIce. JustIce does not only check for      * syntactical correctness but also for semantical sanity - therefore it needs access to the "Code" array of methods in      * a few cases. Please see the pass 3a documentation, too.      *      * @see Pass3aVerifier      */
annotation|@
name|Override
specifier|public
name|VerificationResult
name|do_verify
parameter_list|()
block|{
try|try
block|{
specifier|final
name|VerificationResult
name|vr1
init|=
name|myOwner
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr1
operator|.
name|equals
argument_list|(
name|VerificationResult
operator|.
name|VR_OK
argument_list|)
condition|)
block|{
comment|// For every method, we could have information about the local variables out of LocalVariableTable attributes of
comment|// the Code attributes.
name|localVariablesInfos
operator|=
operator|new
name|LocalVariablesInfo
index|[
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getMethods
argument_list|()
operator|.
name|length
index|]
expr_stmt|;
name|VerificationResult
name|vr
init|=
name|VerificationResult
operator|.
name|VR_OK
decl_stmt|;
comment|// default.
try|try
block|{
name|constant_pool_entries_satisfy_static_constraints
argument_list|()
expr_stmt|;
name|field_and_method_refs_are_valid
argument_list|()
expr_stmt|;
name|every_class_has_an_accessible_superclass
argument_list|()
expr_stmt|;
name|final_methods_are_not_overridden
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassConstraintException
name|cce
parameter_list|)
block|{
name|vr
operator|=
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|vr
return|;
block|}
return|return
name|VerificationResult
operator|.
name|VR_NOTYET
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Ensures that every class has a super class and that<B>final</B> classes are not subclassed. This means, the class      * this Pass2Verifier operates on has proper super classes (transitively) up to java.lang.Object. The reason for really      * loading (and Pass1-verifying) all of those classes here is that we need them in Pass2 anyway to verify no final      * methods are overridden (that could be declared anywhere in the ancestor hierarchy).      *      * @throws ClassConstraintException otherwise.      */
specifier|private
name|void
name|every_class_has_an_accessible_superclass
parameter_list|()
block|{
try|try
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|hs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// save class names to detect circular inheritance
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|supidx
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|supidx
operator|!=
literal|0
condition|)
block|{
name|supidx
operator|=
name|jc
operator|.
name|getSuperclassNameIndex
argument_list|()
expr_stmt|;
if|if
condition|(
name|supidx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|jc
operator|!=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|Type
operator|.
name|OBJECT
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Superclass of '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' missing but not "
operator|+
name|Type
operator|.
name|OBJECT
operator|.
name|getClassName
argument_list|()
operator|+
literal|" itself!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|String
name|supername
init|=
name|jc
operator|.
name|getSuperclassName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hs
operator|.
name|add
argument_list|(
name|supername
argument_list|)
condition|)
block|{
comment|// If supername already is in the list
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Circular superclass hierarchy detected."
argument_list|)
throw|;
block|}
specifier|final
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|supername
argument_list|)
decl_stmt|;
specifier|final
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Could not load in ancestor class '"
operator|+
name|supername
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|jc
operator|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|supername
argument_list|)
expr_stmt|;
if|if
condition|(
name|jc
operator|.
name|isFinal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Ancestor class '"
operator|+
name|supername
operator|+
literal|"' has the FINAL access modifier and must therefore not be subclassed."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Ensures that the ConstantCP-subclassed entries of the constant pool are valid. According to "Yellin: Low Level      * Security in Java", this method does not verify the existence of referenced entities (such as classes) but only the      * formal correctness (such as well-formed signatures). The visitXXX() methods throw ClassConstraintException instances      * otherwise.<B>Precondition: index-style cross referencing in the constant pool must be valid. Simply invoke      * constant_pool_entries_satisfy_static_constraints() before.</B>      *      * @throws ClassConstraintException otherwise.      * @see #constant_pool_entries_satisfy_static_constraints()      */
specifier|private
name|void
name|field_and_method_refs_are_valid
parameter_list|()
block|{
try|try
block|{
specifier|final
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DescendingVisitor
name|v
init|=
operator|new
name|DescendingVisitor
argument_list|(
name|jc
argument_list|,
operator|new
name|FAMRAV_Visitor
argument_list|(
name|jc
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|.
name|visit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Ensures that<B>final</B> methods are not overridden.<B>Precondition to run this method:      * constant_pool_entries_satisfy_static_constraints() and every_class_has_an_accessible_superclass() have to be invoked      * before (in that order).</B>      *      * @throws ClassConstraintException otherwise.      * @see #constant_pool_entries_satisfy_static_constraints()      * @see #every_class_has_an_accessible_superclass()      */
specifier|private
name|void
name|final_methods_are_not_overridden
parameter_list|()
block|{
try|try
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|hashmap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|supidx
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|supidx
operator|!=
literal|0
condition|)
block|{
name|supidx
operator|=
name|jc
operator|.
name|getSuperclassNameIndex
argument_list|()
expr_stmt|;
specifier|final
name|Method
index|[]
name|methods
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Method
name|method
range|:
name|methods
control|)
block|{
specifier|final
name|String
name|nameAndSig
init|=
name|method
operator|.
name|getName
argument_list|()
operator|+
name|method
operator|.
name|getSignature
argument_list|()
decl_stmt|;
if|if
condition|(
name|hashmap
operator|.
name|containsKey
argument_list|(
name|nameAndSig
argument_list|)
condition|)
block|{
if|if
condition|(
name|method
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|method
operator|.
name|isPrivate
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Method '"
operator|+
name|nameAndSig
operator|+
literal|"' in class '"
operator|+
name|hashmap
operator|.
name|get
argument_list|(
name|nameAndSig
argument_list|)
operator|+
literal|"' overrides the final (not-overridable) definition in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|addMessage
argument_list|(
literal|"Method '"
operator|+
name|nameAndSig
operator|+
literal|"' in class '"
operator|+
name|hashmap
operator|.
name|get
argument_list|(
name|nameAndSig
argument_list|)
operator|+
literal|"' overrides the final (not-overridable) definition in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'. This is okay, as the original definition was private; however this constraint leverage"
operator|+
literal|" was introduced by JLS 8.4.6 (not vmspec2) and the behavior of the Sun verifiers."
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|method
operator|.
name|isStatic
argument_list|()
condition|)
block|{
comment|// static methods don't inherit
name|hashmap
operator|.
name|put
argument_list|(
name|nameAndSig
argument_list|,
name|jc
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
operator|!
name|method
operator|.
name|isStatic
argument_list|()
condition|)
block|{
comment|// static methods don't inherit
name|hashmap
operator|.
name|put
argument_list|(
name|nameAndSig
argument_list|,
name|jc
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|jc
operator|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|jc
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Well, for OBJECT this returns OBJECT so it works (could return anything but must not throw an Exception).
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: this might not be the best way to handle missing classes.
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a LocalVariablesInfo object containing information about the usage of the local variables in the Code      * attribute of the said method or<B>null</B> if the class file this Pass2Verifier operates on could not be      * pass-2-verified correctly. The method number method_nr is the method you get using      *<B>Repository.lookupClass(myOwner.getClassname()).getMethods()[method_nr];</B>. You should not add own information.      * Leave that to JustIce.      */
specifier|public
name|LocalVariablesInfo
name|getLocalVariablesInfo
parameter_list|(
specifier|final
name|int
name|methodNr
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|verify
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VR_OK
condition|)
block|{
return|return
literal|null
return|;
comment|// It's cached, don't worry.
block|}
if|if
condition|(
name|methodNr
operator|<
literal|0
operator|||
name|methodNr
operator|>=
name|localVariablesInfos
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Method number out of range."
argument_list|)
throw|;
block|}
return|return
name|localVariablesInfos
index|[
name|methodNr
index|]
return|;
block|}
block|}
end_class

end_unit

