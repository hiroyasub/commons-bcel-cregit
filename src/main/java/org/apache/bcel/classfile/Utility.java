begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|CharArrayReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|CharArrayWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Const
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|util
operator|.
name|ByteSequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|ArrayUtils
import|;
end_import

begin_comment
comment|/**  * Utility functions that do not really belong to any class in particular.  */
end_comment

begin_comment
comment|// @since 6.0 methods are no longer final
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Utility
block|{
comment|/**      * Decode characters into bytes. Used by<a href="Utility.html#decode(java.lang.String, boolean)">decode()</a>      */
specifier|private
specifier|static
class|class
name|JavaReader
extends|extends
name|FilterReader
block|{
specifier|public
name|JavaReader
parameter_list|(
specifier|final
name|Reader
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|ESCAPE_CHAR
condition|)
block|{
return|return
name|b
return|;
block|}
specifier|final
name|int
name|i
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|>=
literal|'0'
operator|&&
name|i
operator|<=
literal|'9'
operator|||
name|i
operator|>=
literal|'a'
operator|&&
name|i
operator|<=
literal|'f'
condition|)
block|{
comment|// Normal escape
specifier|final
name|int
name|j
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|char
index|[]
name|tmp
init|=
block|{
operator|(
name|char
operator|)
name|i
block|,
operator|(
name|char
operator|)
name|j
block|}
decl_stmt|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
operator|new
name|String
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|16
argument_list|)
return|;
block|}
return|return
name|MAP_CHAR
index|[
name|i
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|char
index|[]
name|cbuf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|cbuf
index|[
name|off
operator|+
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
block|}
comment|/**      * Encode bytes into valid java identifier characters. Used by      *<a href="Utility.html#encode(byte[], boolean)">encode()</a>      */
specifier|private
specifier|static
class|class
name|JavaWriter
extends|extends
name|FilterWriter
block|{
specifier|public
name|JavaWriter
parameter_list|(
specifier|final
name|Writer
name|out
parameter_list|)
block|{
name|super
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|char
index|[]
name|cbuf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|write
argument_list|(
name|cbuf
index|[
name|off
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isJavaIdentifierPart
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
operator|&&
name|b
operator|!=
name|ESCAPE_CHAR
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|ESCAPE_CHAR
argument_list|)
expr_stmt|;
comment|// Escape character
comment|// Special escape
if|if
condition|(
name|b
operator|>=
literal|0
operator|&&
name|b
operator|<
name|FREE_CHARS
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|CHAR_MAP
index|[
name|b
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Normal escape
specifier|final
name|char
index|[]
name|tmp
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|b
argument_list|)
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|String
name|str
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|str
operator|.
name|toCharArray
argument_list|()
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * How many chars have been consumed during parsing in typeSignatureToString(). Read by methodSignatureToString(). Set      * by side effect, but only internally.      */
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|CONSUMER_CHARS
init|=
name|ThreadLocal
operator|.
name|withInitial
argument_list|(
parameter_list|()
lambda|->
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/*      * The 'WIDE' instruction is used in the byte code to allow 16-bit wide indices for local variables. This opcode      * precedes an 'ILOAD', e.g.. The opcode immediately following takes an extra byte which is combined with the following      * byte to form a 16-bit value.      */
specifier|private
specifier|static
name|boolean
name|wide
decl_stmt|;
comment|// A-Z, g-z, _, $
specifier|private
specifier|static
specifier|final
name|int
name|FREE_CHARS
init|=
literal|48
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|CHAR_MAP
init|=
operator|new
name|int
index|[
name|FREE_CHARS
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|MAP_CHAR
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
comment|// Reverse map
specifier|private
specifier|static
specifier|final
name|char
name|ESCAPE_CHAR
init|=
literal|'$'
decl_stmt|;
static|static
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
block|{
name|CHAR_MAP
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|MAP_CHAR
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|'g'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|CHAR_MAP
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|MAP_CHAR
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|CHAR_MAP
index|[
name|j
index|]
operator|=
literal|'$'
expr_stmt|;
name|MAP_CHAR
index|[
literal|'$'
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|CHAR_MAP
index|[
name|j
index|]
operator|=
literal|'_'
expr_stmt|;
name|MAP_CHAR
index|[
literal|'_'
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/**      * Convert bit field of flags into string such as 'static final'.      *      * @param accessFlags Access flags      * @return String representation of flags      */
specifier|public
specifier|static
name|String
name|accessToString
parameter_list|(
specifier|final
name|int
name|accessFlags
parameter_list|)
block|{
return|return
name|accessToString
argument_list|(
name|accessFlags
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Convert bit field of flags into string such as 'static final'.      *      * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be "synchronized".      * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.      *      * @param accessFlags Access flags      * @param forClass access flags are for class qualifiers ?      * @return String representation of flags      */
specifier|public
specifier|static
name|String
name|accessToString
parameter_list|(
specifier|final
name|int
name|accessFlags
parameter_list|,
specifier|final
name|boolean
name|forClass
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|p
operator|<
name|Const
operator|.
name|MAX_ACC_FLAG_I
condition|;
name|i
operator|++
control|)
block|{
comment|// Loop through known flags
name|p
operator|=
name|pow2
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|accessFlags
operator|&
name|p
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*                  * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be "synchronized".                  * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.                  */
if|if
condition|(
name|forClass
operator|&&
operator|(
name|p
operator|==
name|Const
operator|.
name|ACC_SUPER
operator|||
name|p
operator|==
name|Const
operator|.
name|ACC_INTERFACE
operator|)
condition|)
block|{
continue|continue;
block|}
name|buf
operator|.
name|append
argument_list|(
name|Const
operator|.
name|getAccessName
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
comment|/**      * Convert (signed) byte to (unsigned) short value, i.e., all negative values become positive.      */
specifier|private
specifier|static
name|short
name|byteToShort
parameter_list|(
specifier|final
name|byte
name|b
parameter_list|)
block|{
return|return
name|b
operator|<
literal|0
condition|?
operator|(
name|short
operator|)
operator|(
literal|256
operator|+
name|b
operator|)
else|:
operator|(
name|short
operator|)
name|b
return|;
block|}
comment|/**      * @param accessFlags the class flags      *      * @return "class" or "interface", depending on the ACC_INTERFACE flag      */
specifier|public
specifier|static
name|String
name|classOrInterface
parameter_list|(
specifier|final
name|int
name|accessFlags
parameter_list|)
block|{
return|return
operator|(
name|accessFlags
operator|&
name|Const
operator|.
name|ACC_INTERFACE
operator|)
operator|!=
literal|0
condition|?
literal|"interface"
else|:
literal|"class"
return|;
block|}
comment|/**      * @return 'flag' with bit 'i' set to 0      */
specifier|public
specifier|static
name|int
name|clearBit
parameter_list|(
specifier|final
name|int
name|flag
parameter_list|,
specifier|final
name|int
name|i
parameter_list|)
block|{
specifier|final
name|int
name|bit
init|=
name|pow2
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
operator|(
name|flag
operator|&
name|bit
operator|)
operator|==
literal|0
condition|?
name|flag
else|:
name|flag
operator|^
name|bit
return|;
block|}
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
specifier|final
name|byte
index|[]
name|code
parameter_list|,
specifier|final
name|ConstantPool
name|constantPool
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
name|codeToString
argument_list|(
name|code
argument_list|,
name|constantPool
argument_list|,
name|index
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Disassemble a byte array of JVM byte codes starting from code line 'index' and return the disassembled string      * representation. Decode only 'num' opcodes (including their operands), use -1 if you want to decompile everything.      *      * @param code byte code array      * @param constantPool Array of constants      * @param index offset in 'code' array<EM>(number of opcodes, not bytes!)</EM>      * @param length number of opcodes to decompile, -1 for all      * @param verbose be verbose, e.g. print constant pool index      * @return String representation of byte codes      */
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
specifier|final
name|byte
index|[]
name|code
parameter_list|,
specifier|final
name|ConstantPool
name|constantPool
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|boolean
name|verbose
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|code
operator|.
name|length
operator|*
literal|20
argument_list|)
decl_stmt|;
comment|// Should be sufficient // CHECKSTYLE IGNORE MagicNumber
try|try
init|(
name|ByteSequence
name|stream
init|=
operator|new
name|ByteSequence
argument_list|(
name|code
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|codeToString
argument_list|(
name|stream
argument_list|,
name|constantPool
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|stream
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|length
operator|<
literal|0
operator|||
name|i
operator|<
name|length
condition|)
block|{
specifier|final
name|String
name|indices
init|=
name|fillup
argument_list|(
name|stream
operator|.
name|getIndex
argument_list|()
operator|+
literal|":"
argument_list|,
literal|6
argument_list|,
literal|true
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|indices
argument_list|)
operator|.
name|append
argument_list|(
name|codeToString
argument_list|(
name|stream
argument_list|,
name|constantPool
argument_list|,
name|verbose
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Byte code error: "
operator|+
name|buf
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
specifier|final
name|ByteSequence
name|bytes
parameter_list|,
specifier|final
name|ConstantPool
name|constantPool
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|codeToString
argument_list|(
name|bytes
argument_list|,
name|constantPool
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Disassemble a stream of byte codes and return the string representation.      *      * @param bytes stream of bytes      * @param constantPool Array of constants      * @param verbose be verbose, e.g. print constant pool index      * @return String representation of byte code      *      * @throws IOException if a failure from reading from the bytes argument occurs      */
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
specifier|final
name|ByteSequence
name|bytes
parameter_list|,
specifier|final
name|ConstantPool
name|constantPool
parameter_list|,
specifier|final
name|boolean
name|verbose
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|short
name|opcode
init|=
operator|(
name|short
operator|)
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
decl_stmt|;
name|int
name|defaultOffset
init|=
literal|0
decl_stmt|;
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
name|int
name|npairs
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|vindex
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|int
index|[]
name|match
decl_stmt|;
name|int
index|[]
name|jumpTable
decl_stmt|;
name|int
name|noPadBytes
init|=
literal|0
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|Const
operator|.
name|getOpcodeName
argument_list|(
name|opcode
argument_list|)
argument_list|)
decl_stmt|;
comment|/*          * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned          */
if|if
condition|(
name|opcode
operator|==
name|Const
operator|.
name|TABLESWITCH
operator|||
name|opcode
operator|==
name|Const
operator|.
name|LOOKUPSWITCH
condition|)
block|{
specifier|final
name|int
name|remainder
init|=
name|bytes
operator|.
name|getIndex
argument_list|()
operator|%
literal|4
decl_stmt|;
name|noPadBytes
operator|=
name|remainder
operator|==
literal|0
condition|?
literal|0
else|:
literal|4
operator|-
name|remainder
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|noPadBytes
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|bytes
operator|.
name|readByte
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Warning: Padding byte != 0 in "
operator|+
name|Const
operator|.
name|getOpcodeName
argument_list|(
name|opcode
argument_list|)
operator|+
literal|":"
operator|+
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Both cases have a field default_offset in common
name|defaultOffset
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/*          * Table switch has variable length arguments.          */
case|case
name|Const
operator|.
name|TABLESWITCH
case|:
name|low
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|high
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|offset
operator|=
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|12
operator|-
name|noPadBytes
operator|-
literal|1
expr_stmt|;
name|defaultOffset
operator|+=
name|offset
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\tdefault = "
argument_list|)
operator|.
name|append
argument_list|(
name|defaultOffset
argument_list|)
operator|.
name|append
argument_list|(
literal|", low = "
argument_list|)
operator|.
name|append
argument_list|(
name|low
argument_list|)
operator|.
name|append
argument_list|(
literal|", high = "
argument_list|)
operator|.
name|append
argument_list|(
name|high
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|jumpTable
operator|=
operator|new
name|int
index|[
name|high
operator|-
name|low
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jumpTable
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|jumpTable
index|[
name|i
index|]
operator|=
name|offset
operator|+
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|jumpTable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|jumpTable
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Lookup switch has variable length arguments.          */
case|case
name|Const
operator|.
name|LOOKUPSWITCH
case|:
block|{
name|npairs
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|offset
operator|=
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|8
operator|-
name|noPadBytes
operator|-
literal|1
expr_stmt|;
name|match
operator|=
operator|new
name|int
index|[
name|npairs
index|]
expr_stmt|;
name|jumpTable
operator|=
operator|new
name|int
index|[
name|npairs
index|]
expr_stmt|;
name|defaultOffset
operator|+=
name|offset
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\tdefault = "
argument_list|)
operator|.
name|append
argument_list|(
name|defaultOffset
argument_list|)
operator|.
name|append
argument_list|(
literal|", npairs = "
argument_list|)
operator|.
name|append
argument_list|(
name|npairs
argument_list|)
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|npairs
condition|;
name|i
operator|++
control|)
block|{
name|match
index|[
name|i
index|]
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|jumpTable
index|[
name|i
index|]
operator|=
name|offset
operator|+
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|match
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|jumpTable
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|npairs
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*          * Two address bytes + offset from start of byte stream form the jump target          */
case|case
name|Const
operator|.
name|GOTO
case|:
case|case
name|Const
operator|.
name|IFEQ
case|:
case|case
name|Const
operator|.
name|IFGE
case|:
case|case
name|Const
operator|.
name|IFGT
case|:
case|case
name|Const
operator|.
name|IFLE
case|:
case|case
name|Const
operator|.
name|IFLT
case|:
case|case
name|Const
operator|.
name|JSR
case|:
case|case
name|Const
operator|.
name|IFNE
case|:
case|case
name|Const
operator|.
name|IFNONNULL
case|:
case|case
name|Const
operator|.
name|IFNULL
case|:
case|case
name|Const
operator|.
name|IF_ACMPEQ
case|:
case|case
name|Const
operator|.
name|IF_ACMPNE
case|:
case|case
name|Const
operator|.
name|IF_ICMPEQ
case|:
case|case
name|Const
operator|.
name|IF_ICMPGE
case|:
case|case
name|Const
operator|.
name|IF_ICMPGT
case|:
case|case
name|Const
operator|.
name|IF_ICMPLE
case|:
case|case
name|Const
operator|.
name|IF_ICMPLT
case|:
case|case
name|Const
operator|.
name|IF_ICMPNE
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t#"
argument_list|)
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
operator|+
name|bytes
operator|.
name|readShort
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/*          * 32-bit wide jumps          */
case|case
name|Const
operator|.
name|GOTO_W
case|:
case|case
name|Const
operator|.
name|JSR_W
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t#"
argument_list|)
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
operator|+
name|bytes
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Index byte references local variable (register)          */
case|case
name|Const
operator|.
name|ALOAD
case|:
case|case
name|Const
operator|.
name|ASTORE
case|:
case|case
name|Const
operator|.
name|DLOAD
case|:
case|case
name|Const
operator|.
name|DSTORE
case|:
case|case
name|Const
operator|.
name|FLOAD
case|:
case|case
name|Const
operator|.
name|FSTORE
case|:
case|case
name|Const
operator|.
name|ILOAD
case|:
case|case
name|Const
operator|.
name|ISTORE
case|:
case|case
name|Const
operator|.
name|LLOAD
case|:
case|case
name|Const
operator|.
name|LSTORE
case|:
case|case
name|Const
operator|.
name|RET
case|:
if|if
condition|(
name|wide
condition|)
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|wide
operator|=
literal|false
expr_stmt|;
comment|// Clear flag
block|}
else|else
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t%"
argument_list|)
operator|.
name|append
argument_list|(
name|vindex
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is          * called again with the following opcode.          */
case|case
name|Const
operator|.
name|WIDE
case|:
name|wide
operator|=
literal|true
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t(wide)"
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Array of basic type.          */
case|case
name|Const
operator|.
name|NEWARRAY
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|Const
operator|.
name|getTypeName
argument_list|(
name|bytes
operator|.
name|readByte
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Access object/class fields.          */
case|case
name|Const
operator|.
name|GETFIELD
case|:
case|case
name|Const
operator|.
name|GETSTATIC
case|:
case|case
name|Const
operator|.
name|PUTFIELD
case|:
case|case
name|Const
operator|.
name|PUTSTATIC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_Fieldref
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Operands are references to classes in constant pool          */
case|case
name|Const
operator|.
name|NEW
case|:
case|case
name|Const
operator|.
name|CHECKCAST
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
comment|//$FALL-THROUGH$
case|case
name|Const
operator|.
name|INSTANCEOF
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_Class
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Operands are references to methods in constant pool          */
case|case
name|Const
operator|.
name|INVOKESPECIAL
case|:
case|case
name|Const
operator|.
name|INVOKESTATIC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
specifier|final
name|Constant
name|c
init|=
name|constantPool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// With Java8 operand may be either a CONSTANT_Methodref
comment|// or a CONSTANT_InterfaceMethodref. (markro)
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|c
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|Const
operator|.
name|INVOKEVIRTUAL
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_Methodref
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|Const
operator|.
name|INVOKEINTERFACE
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
specifier|final
name|int
name|nargs
init|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
decl_stmt|;
comment|// historical, redundant
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_InterfaceMethodref
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")\t"
else|:
literal|""
argument_list|)
operator|.
name|append
argument_list|(
name|nargs
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
argument_list|)
expr_stmt|;
comment|// Last byte is a reserved space
break|break;
case|case
name|Const
operator|.
name|INVOKEDYNAMIC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_InvokeDynamic
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")\t"
else|:
literal|""
argument_list|)
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
argument_list|)
comment|// Thrid byte is a reserved space
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
argument_list|)
expr_stmt|;
comment|// Last byte is a reserved space
break|break;
comment|/*          * Operands are references to items in constant pool          */
case|case
name|Const
operator|.
name|LDC_W
case|:
case|case
name|Const
operator|.
name|LDC2_W
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|constantPool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|Const
operator|.
name|LDC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constantPool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|constantPool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Array of references.          */
case|case
name|Const
operator|.
name|ANEWARRAY
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|compactClassName
argument_list|(
name|constantPool
operator|.
name|getConstantString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_Class
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
comment|/*          * Multidimensional array of references.          */
case|case
name|Const
operator|.
name|MULTIANEWARRAY
case|:
block|{
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
specifier|final
name|int
name|dimensions
init|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|compactClassName
argument_list|(
name|constantPool
operator|.
name|getConstantString
argument_list|(
name|index
argument_list|,
name|Const
operator|.
name|CONSTANT_Class
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">\t"
argument_list|)
operator|.
name|append
argument_list|(
name|dimensions
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*          * Increment local variable.          */
case|case
name|Const
operator|.
name|IINC
case|:
if|if
condition|(
name|wide
condition|)
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|constant
operator|=
name|bytes
operator|.
name|readShort
argument_list|()
expr_stmt|;
name|wide
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
expr_stmt|;
name|constant
operator|=
name|bytes
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t%"
argument_list|)
operator|.
name|append
argument_list|(
name|vindex
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|Const
operator|.
name|getNoOfOperands
argument_list|(
name|opcode
argument_list|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Const
operator|.
name|getOperandTypeCount
argument_list|(
name|opcode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Const
operator|.
name|getOperandType
argument_list|(
name|opcode
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|Const
operator|.
name|T_BYTE
case|:
name|buf
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readByte
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Const
operator|.
name|T_SHORT
case|:
name|buf
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readShort
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Const
operator|.
name|T_INT
case|:
name|buf
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Never reached
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unreachable default case reached!"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Shorten long class names,<em>java/lang/String</em> becomes<em>String</em>.      *      * @param str The long class name      * @return Compacted class name      */
specifier|public
specifier|static
name|String
name|compactClassName
parameter_list|(
specifier|final
name|String
name|str
parameter_list|)
block|{
return|return
name|compactClassName
argument_list|(
name|str
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Shorten long class names,<em>java/lang/String</em> becomes<em>java.lang.String</em>, e.g.. If<em>chopit</em> is      *<em>true</em> the prefix<em>java.lang</em> is also removed.      *      * @param str The long class name      * @param chopit flag that determines whether chopping is executed or not      * @return Compacted class name      */
specifier|public
specifier|static
name|String
name|compactClassName
parameter_list|(
specifier|final
name|String
name|str
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
block|{
return|return
name|compactClassName
argument_list|(
name|str
argument_list|,
literal|"java.lang."
argument_list|,
name|chopit
argument_list|)
return|;
block|}
comment|/**      * Shorten long class name<em>str</em>, i.e., chop off the<em>prefix</em>, if the class name starts with this string      * and the flag<em>chopit</em> is true. Slashes<em>/</em> are converted to dots<em>.</em>.      *      * @param str The long class name      * @param prefix The prefix the get rid off      * @param chopit flag that determines whether chopping is executed or not      * @return Compacted class name      */
specifier|public
specifier|static
name|String
name|compactClassName
parameter_list|(
name|String
name|str
parameter_list|,
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|prefix
operator|.
name|length
argument_list|()
decl_stmt|;
name|str
operator|=
name|pathToPackage
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|// Is '/' on all systems, even DOS
comment|// If string starts with 'prefix' and contains no further dots
if|if
condition|(
name|chopit
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
operator|&&
name|str
operator|.
name|substring
argument_list|(
name|len
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|str
operator|=
name|str
operator|.
name|substring
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
comment|/**      * Escape all occurrences of newline chars '\n', quotes \", etc.      */
specifier|public
specifier|static
name|String
name|convertString
parameter_list|(
specifier|final
name|String
name|label
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|ch
init|=
name|label
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|char
name|element
range|:
name|ch
control|)
block|{
switch|switch
condition|(
name|element
condition|)
block|{
case|case
literal|'\n'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|buf
operator|.
name|append
argument_list|(
name|element
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|int
name|countBrackets
parameter_list|(
specifier|final
name|String
name|brackets
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|chars
init|=
name|brackets
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|boolean
name|open
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|final
name|char
name|c
range|:
name|chars
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'['
case|:
if|if
condition|(
name|open
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegally nested brackets:"
operator|+
name|brackets
argument_list|)
throw|;
block|}
name|open
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
operator|!
name|open
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegally nested brackets:"
operator|+
name|brackets
argument_list|)
throw|;
block|}
name|open
operator|=
literal|false
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
default|default:
comment|// Don't care
break|break;
block|}
block|}
if|if
condition|(
name|open
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegally nested brackets:"
operator|+
name|brackets
argument_list|)
throw|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Decode a string back to a byte array.      *      * @param s the string to convert      * @param uncompress use gzip to uncompress the stream of bytes      *      * @throws IOException if there's a gzip exception      */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
specifier|final
name|String
name|s
parameter_list|,
specifier|final
name|boolean
name|uncompress
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
init|(
name|JavaReader
name|jr
init|=
operator|new
name|JavaReader
argument_list|(
operator|new
name|CharArrayReader
argument_list|(
name|s
operator|.
name|toCharArray
argument_list|()
argument_list|)
argument_list|)
init|;
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|jr
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|bos
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
name|bos
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uncompress
condition|)
block|{
specifier|final
name|GZIPInputStream
name|gis
init|=
operator|new
name|GZIPInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|tmp
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
operator|*
literal|3
index|]
decl_stmt|;
comment|// Rough estimate
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|gis
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|tmp
index|[
name|count
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
name|bytes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|tmp
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|/**      * Encode byte array it into Java identifier string, i.e., a string that only contains the following characters: (a, ...      * z, A, ... Z, 0, ... 9, _, $). The encoding algorithm itself is not too clever: if the current byte's ASCII value      * already is a valid Java identifier part, leave it as it is. Otherwise it writes the escape character($) followed by:      *      *<ul>      *<li>the ASCII value as a hexadecimal string, if the value is not in the range 200..247</li>      *<li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247</li>      *</ul>      *      *<p>      * This operation inflates the original byte array by roughly 40-50%      *</p>      *      * @param bytes the byte array to convert      * @param compress use gzip to minimize string      *      * @throws IOException if there's a gzip exception      */
specifier|public
specifier|static
name|String
name|encode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|boolean
name|compress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|compress
condition|)
block|{
try|try
init|(
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|;
name|GZIPOutputStream
name|gos
init|=
operator|new
name|GZIPOutputStream
argument_list|(
name|baos
argument_list|)
init|)
block|{
name|gos
operator|.
name|write
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|gos
operator|.
name|close
argument_list|()
expr_stmt|;
name|bytes
operator|=
name|baos
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|CharArrayWriter
name|caw
init|=
operator|new
name|CharArrayWriter
argument_list|()
decl_stmt|;
try|try
init|(
name|JavaWriter
name|jw
init|=
operator|new
name|JavaWriter
argument_list|(
name|caw
argument_list|)
init|)
block|{
for|for
control|(
specifier|final
name|byte
name|b
range|:
name|bytes
control|)
block|{
specifier|final
name|int
name|in
init|=
name|b
operator|&
literal|0x000000ff
decl_stmt|;
comment|// Normalize to unsigned
name|jw
operator|.
name|write
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|caw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Fillup char with up to length characters with char 'fill' and justify it left or right.      *      * @param str string to format      * @param length length of desired string      * @param leftJustify format left or right      * @param fill fill character      * @return formatted string      */
specifier|public
specifier|static
name|String
name|fillup
parameter_list|(
specifier|final
name|String
name|str
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|boolean
name|leftJustify
parameter_list|,
specifier|final
name|char
name|fill
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|length
operator|-
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|char
index|[]
name|buf
init|=
operator|new
name|char
index|[
name|Math
operator|.
name|max
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|buf
argument_list|,
name|fill
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftJustify
condition|)
block|{
return|return
name|str
operator|+
operator|new
name|String
argument_list|(
name|buf
argument_list|)
return|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buf
argument_list|)
operator|+
name|str
return|;
block|}
comment|/**      * Return a string for an integer justified left or right and filled up with 'fill' characters if necessary.      *      * @param i integer to format      * @param length length of desired string      * @param leftJustify format left or right      * @param fill fill character      * @return formatted int      */
specifier|public
specifier|static
name|String
name|format
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|boolean
name|leftJustify
parameter_list|,
specifier|final
name|char
name|fill
parameter_list|)
block|{
return|return
name|fillup
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|,
name|length
argument_list|,
name|leftJustify
argument_list|,
name|fill
argument_list|)
return|;
block|}
comment|/**      * WARNING:      *      * There is some nomenclature confusion through much of the BCEL code base with respect to the terms Descriptor and      * Signature. For the offical definitions see:      *      * @see<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3"> Descriptors in The Java      *      Virtual Machine Specification</a>      *      * @see<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1"> Signatures in The Java      *      Virtual Machine Specification</a>      *      *      In brief, a descriptor is a string representing the type of a field or method. Signatures are similar, but more      *      complex. Signatures are used to encode declarations written in the Java programming language that use types      *      outside the type system of the Java Virtual Machine. They are used to describe the type of any class, interface,      *      constructor, method or field whose declaration uses type variables or parameterized types.      *      *      To parse a descriptor, call typeSignatureToString. To parse a signature, call signatureToString.      *      *      Note that if the signature string is a single, non-generic item, the call to signatureToString reduces to a call      *      to typeSignatureToString. Also note, that if you only wish to parse the first item in a longer signature string,      *      you should call typeSignatureToString directly.      */
comment|/**      * Parse Java type such as "char", or "java.lang.String[]" and return the signature in byte code format, e.g. "C" or      * "[Ljava/lang/String;" respectively.      *      * @param type Java type      * @return byte code signature      */
specifier|public
specifier|static
name|String
name|getSignature
parameter_list|(
name|String
name|type
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|char
index|[]
name|chars
init|=
name|type
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|boolean
name|charFound
init|=
literal|false
decl_stmt|;
name|boolean
name|delim
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|loop
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|chars
index|[
name|i
index|]
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\f'
case|:
if|if
condition|(
name|charFound
condition|)
block|{
name|delim
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
if|if
condition|(
operator|!
name|charFound
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal type: "
operator|+
name|type
argument_list|)
throw|;
block|}
name|index
operator|=
name|i
expr_stmt|;
break|break
name|loop
break|;
default|default:
name|charFound
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|delim
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|brackets
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|brackets
operator|=
name|countBrackets
argument_list|(
name|type
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|brackets
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Const
operator|.
name|T_BOOLEAN
init|;
name|i
operator|<=
name|Const
operator|.
name|T_VOID
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Const
operator|.
name|getTypeName
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Const
operator|.
name|getShortTypeName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'L'
argument_list|)
operator|.
name|append
argument_list|(
name|packageToPath
argument_list|(
name|type
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @param ch the character to test if it's part of an identifier      *      * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)      */
specifier|public
specifier|static
name|boolean
name|isJavaIdentifierPart
parameter_list|(
specifier|final
name|char
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|||
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|||
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|||
name|ch
operator|==
literal|'_'
return|;
block|}
comment|/**      * @return true, if bit 'i' in 'flag' is set      */
specifier|public
specifier|static
name|boolean
name|isSet
parameter_list|(
specifier|final
name|int
name|flag
parameter_list|,
specifier|final
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|flag
operator|&
name|pow2
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
comment|/**      * Converts argument list portion of method signature to string with all class names compacted.      *      * @param signature Method signature      * @return String Array of argument types      * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file      */
specifier|public
specifier|static
name|String
index|[]
name|methodSignatureArgumentTypes
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
return|return
name|methodSignatureArgumentTypes
argument_list|(
name|signature
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Converts argument list portion of method signature to string.      *      * @param signature Method signature      * @param chopit flag that determines whether chopping is executed or not      * @return String Array of argument types      * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file      */
specifier|public
specifier|static
name|String
index|[]
name|methodSignatureArgumentTypes
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
throws|throws
name|ClassFormatException
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|vec
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|index
decl_stmt|;
try|try
block|{
comment|// Skip any type arguments to read argument declarations between '(' and ')'
name|index
operator|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|)
throw|;
block|}
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
literal|')'
condition|)
block|{
name|vec
operator|.
name|add
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
comment|// corrected concurrent private static field acess
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|vec
operator|.
name|toArray
argument_list|(
name|ArrayUtils
operator|.
name|EMPTY_STRING_ARRAY
argument_list|)
return|;
block|}
comment|/**      * Converts return type portion of method signature to string with all class names compacted.      *      * @param signature Method signature      * @return String representation of method return type      * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file      */
specifier|public
specifier|static
name|String
name|methodSignatureReturnType
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
return|return
name|methodSignatureReturnType
argument_list|(
name|signature
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Converts return type portion of method signature to string.      *      * @param signature Method signature      * @param chopit flag that determines whether chopping is executed or not      * @return String representation of method return type      * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file      */
specifier|public
specifier|static
name|String
name|methodSignatureReturnType
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|int
name|index
decl_stmt|;
name|String
name|type
decl_stmt|;
try|try
block|{
comment|// Read return type after ')'
name|index
operator|=
name|signature
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|)
throw|;
block|}
name|type
operator|=
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|type
return|;
block|}
comment|/**      * Converts method signature to string with all class names compacted.      *      * @param signature to convert      * @param name of method      * @param access flags of method      * @return Human readable signature      */
specifier|public
specifier|static
name|String
name|methodSignatureToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|String
name|access
parameter_list|)
block|{
return|return
name|methodSignatureToString
argument_list|(
name|signature
argument_list|,
name|name
argument_list|,
name|access
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Converts method signature to string.      *      * @param signature to convert      * @param name of method      * @param access flags of method      * @param chopit flag that determines whether chopping is executed or not      * @return Human readable signature      */
specifier|public
specifier|static
name|String
name|methodSignatureToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|String
name|access
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
block|{
return|return
name|methodSignatureToString
argument_list|(
name|signature
argument_list|,
name|name
argument_list|,
name|access
argument_list|,
name|chopit
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * This method converts a method signature string into a Java type declaration like 'void main(String[])' and throws a      * 'ClassFormatException' when the parsed type is invalid.      *      * @param signature Method signature      * @param name Method name      * @param access Method access rights      * @param chopit flag that determines whether chopping is executed or not      * @param vars the LocalVariableTable for the method      * @return Java type declaration      * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file      */
specifier|public
specifier|static
name|String
name|methodSignatureToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|String
name|access
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|,
specifier|final
name|LocalVariableTable
name|vars
parameter_list|)
throws|throws
name|ClassFormatException
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"("
argument_list|)
decl_stmt|;
name|String
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|varIndex
init|=
name|access
operator|.
name|contains
argument_list|(
literal|"static"
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
try|try
block|{
comment|// Skip any type arguments to read argument declarations between '(' and ')'
name|index
operator|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|)
throw|;
block|}
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
literal|')'
condition|)
block|{
specifier|final
name|String
name|paramType
init|=
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|paramType
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|!=
literal|null
condition|)
block|{
specifier|final
name|LocalVariable
name|l
init|=
name|vars
operator|.
name|getLocalVariable
argument_list|(
name|varIndex
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|l
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" arg"
argument_list|)
operator|.
name|append
argument_list|(
name|varIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"double"
operator|.
name|equals
argument_list|(
name|paramType
argument_list|)
operator|||
literal|"long"
operator|.
name|equals
argument_list|(
name|paramType
argument_list|)
condition|)
block|{
name|varIndex
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|varIndex
operator|++
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
comment|// corrected concurrent private static field acess
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
name|index
operator|++
expr_stmt|;
comment|// update position
comment|// Read return type after ')'
name|type
operator|=
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// ignore any throws information in the signature
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|buf
operator|.
name|setLength
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|access
operator|+
operator|(
operator|!
name|access
operator|.
name|isEmpty
argument_list|()
condition|?
literal|" "
else|:
literal|""
operator|)
operator|+
comment|// May be an empty string
name|type
operator|+
literal|" "
operator|+
name|name
operator|+
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts string containing the method return and argument types to a byte code method signature.      *      * @param ret Return type of method      * @param argv Types of method arguments      * @return Byte code representation of method signature      *      * @throws ClassFormatException if the signature is for Void      */
specifier|public
specifier|static
name|String
name|methodTypeToSignature
parameter_list|(
specifier|final
name|String
name|ret
parameter_list|,
specifier|final
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|ClassFormatException
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"("
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
if|if
condition|(
name|argv
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|String
name|element
range|:
name|argv
control|)
block|{
name|str
operator|=
name|getSignature
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
literal|"V"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid type: "
operator|+
name|element
argument_list|)
throw|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
name|str
operator|=
name|getSignature
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts '.'s to '/'s.      *      * @param name Source      * @return converted value      * @since 6.7.0      */
specifier|public
specifier|static
name|String
name|packageToPath
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
return|;
block|}
comment|/**      * Converts a path to a package name.      *      * @param str the source path.      * @return a package name.      * @since 6.6.0      */
specifier|public
specifier|static
name|String
name|pathToPackage
parameter_list|(
specifier|final
name|String
name|str
parameter_list|)
block|{
return|return
name|str
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|pow2
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
return|return
literal|1
operator|<<
name|n
return|;
block|}
specifier|public
specifier|static
name|String
name|printArray
parameter_list|(
specifier|final
name|Object
index|[]
name|obj
parameter_list|)
block|{
return|return
name|printArray
argument_list|(
name|obj
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|printArray
parameter_list|(
specifier|final
name|Object
index|[]
name|obj
parameter_list|,
specifier|final
name|boolean
name|braces
parameter_list|)
block|{
return|return
name|printArray
argument_list|(
name|obj
argument_list|,
name|braces
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|printArray
parameter_list|(
specifier|final
name|Object
index|[]
name|obj
parameter_list|,
specifier|final
name|boolean
name|braces
parameter_list|,
specifier|final
name|boolean
name|quote
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|braces
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|obj
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|quote
condition|?
literal|"\""
else|:
literal|""
argument_list|)
operator|.
name|append
argument_list|(
name|obj
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
name|quote
condition|?
literal|"\""
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|obj
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|braces
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|void
name|printArray
parameter_list|(
specifier|final
name|PrintStream
name|out
parameter_list|,
specifier|final
name|Object
index|[]
name|obj
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|printArray
argument_list|(
name|obj
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|printArray
parameter_list|(
specifier|final
name|PrintWriter
name|out
parameter_list|,
specifier|final
name|Object
index|[]
name|obj
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|printArray
argument_list|(
name|obj
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replace all occurrences of<em>old</em> in<em>str</em> with<em>new</em>.      *      * @param str String to permute      * @param old String to be replaced      * @param new_ Replacement string      * @return new String object      */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|str
parameter_list|,
specifier|final
name|String
name|old
parameter_list|,
specifier|final
name|String
name|new_
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|oldIndex
decl_stmt|;
try|try
block|{
if|if
condition|(
name|str
operator|.
name|contains
argument_list|(
name|old
argument_list|)
condition|)
block|{
comment|// 'old' found in str
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|oldIndex
operator|=
literal|0
expr_stmt|;
comment|// String start offset
comment|// While we have something to replace
while|while
condition|(
operator|(
name|index
operator|=
name|str
operator|.
name|indexOf
argument_list|(
name|old
argument_list|,
name|oldIndex
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|str
argument_list|,
name|oldIndex
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// append prefix
name|buf
operator|.
name|append
argument_list|(
name|new_
argument_list|)
expr_stmt|;
comment|// append replacement
name|oldIndex
operator|=
name|index
operator|+
name|old
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// Skip 'old'.length chars
block|}
name|buf
operator|.
name|append
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|oldIndex
argument_list|)
argument_list|)
expr_stmt|;
comment|// append rest of string
name|str
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should not occur
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
comment|/**      * Map opcode names to opcode numbers. E.g., return Constants.ALOAD for "aload"      */
specifier|public
specifier|static
name|short
name|searchOpcode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|name
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Const
operator|.
name|OPCODE_NAMES_LENGTH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Const
operator|.
name|getOpcodeName
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * @return 'flag' with bit 'i' set to 1      */
specifier|public
specifier|static
name|int
name|setBit
parameter_list|(
specifier|final
name|int
name|flag
parameter_list|,
specifier|final
name|int
name|i
parameter_list|)
block|{
return|return
name|flag
operator||
name|pow2
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Converts a signature to a string with all class names compacted. Class, Method and Type signatures are supported.      * Enum and Interface signatures are not supported.      *      * @param signature signature to convert      * @return String containg human readable signature      */
specifier|public
specifier|static
name|String
name|signatureToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|)
block|{
return|return
name|signatureToString
argument_list|(
name|signature
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Converts a signature to a string. Class, Method and Type signatures are supported. Enum and Interface signatures are      * not supported.      *      * @param signature signature to convert      * @param chopit flag that determines whether chopping is executed or not      * @return String containg human readable signature      */
specifier|public
specifier|static
name|String
name|signatureToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
block|{
name|String
name|type
init|=
literal|""
decl_stmt|;
name|String
name|typeParams
init|=
literal|""
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'<'
condition|)
block|{
comment|// we have type paramters
name|typeParams
operator|=
name|typeParamTypesToString
argument_list|(
name|signature
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|==
literal|'('
condition|)
block|{
comment|// We have a Method signature.
comment|// add types of arguments
name|type
operator|=
name|typeParams
operator|+
name|typeSignaturesToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
comment|// add return type
name|type
operator|=
name|type
operator|+
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
comment|// ignore any throws information in the signature
return|return
name|type
return|;
block|}
comment|// Could be Class or Type...
name|type
operator|=
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
if|if
condition|(
name|typeParams
operator|.
name|isEmpty
argument_list|()
operator|&&
name|index
operator|==
name|signature
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// We have a Type signature.
return|return
name|type
return|;
block|}
comment|// We have a Class signature.
specifier|final
name|StringBuilder
name|typeClass
init|=
operator|new
name|StringBuilder
argument_list|(
name|typeParams
argument_list|)
decl_stmt|;
name|typeClass
operator|.
name|append
argument_list|(
literal|" extends "
argument_list|)
expr_stmt|;
name|typeClass
operator|.
name|append
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|signature
operator|.
name|length
argument_list|()
condition|)
block|{
name|typeClass
operator|.
name|append
argument_list|(
literal|" implements "
argument_list|)
expr_stmt|;
name|typeClass
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
while|while
condition|(
name|index
operator|<
name|signature
operator|.
name|length
argument_list|()
condition|)
block|{
name|typeClass
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|typeClass
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
return|return
name|typeClass
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Convert bytes into hexadecimal string      *      * @param bytes an array of bytes to convert to hexadecimal      *      * @return bytes as hexadecimal string, e.g. 00 fa 12 ...      */
specifier|public
specifier|static
name|String
name|toHexString
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|short
name|b
init|=
name|byteToShort
argument_list|(
name|bytes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|final
name|String
name|hex
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0x10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|bytes
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Return type of method signature as a byte value as defined in<em>Constants</em>      *      * @param signature in format described above      * @return type of method signature      * @see Const      *      * @throws ClassFormatException if signature is not a method signature      */
specifier|public
specifier|static
name|byte
name|typeOfMethodSignature
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|int
name|index
decl_stmt|;
try|try
block|{
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'('
condition|)
block|{
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|)
throw|;
block|}
name|index
operator|=
name|signature
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|typeOfSignature
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Return type of signature as a byte value as defined in<em>Constants</em>      *      * @param signature in format described above      * @return type of signature      * @see Const      *      * @throws ClassFormatException if signature isn't a known type      */
specifier|public
specifier|static
name|byte
name|typeOfSignature
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
try|try
block|{
switch|switch
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'B'
case|:
return|return
name|Const
operator|.
name|T_BYTE
return|;
case|case
literal|'C'
case|:
return|return
name|Const
operator|.
name|T_CHAR
return|;
case|case
literal|'D'
case|:
return|return
name|Const
operator|.
name|T_DOUBLE
return|;
case|case
literal|'F'
case|:
return|return
name|Const
operator|.
name|T_FLOAT
return|;
case|case
literal|'I'
case|:
return|return
name|Const
operator|.
name|T_INT
return|;
case|case
literal|'J'
case|:
return|return
name|Const
operator|.
name|T_LONG
return|;
case|case
literal|'L'
case|:
case|case
literal|'T'
case|:
return|return
name|Const
operator|.
name|T_REFERENCE
return|;
case|case
literal|'['
case|:
return|return
name|Const
operator|.
name|T_ARRAY
return|;
case|case
literal|'V'
case|:
return|return
name|Const
operator|.
name|T_VOID
return|;
case|case
literal|'Z'
case|:
return|return
name|Const
operator|.
name|T_BOOLEAN
return|;
case|case
literal|'S'
case|:
return|return
name|Const
operator|.
name|T_SHORT
return|;
case|case
literal|'!'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
return|return
name|typeOfSignature
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidMethodSignatureException
argument_list|(
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Converts a type parameter list signature to a string.      *      * @param signature signature to convert      * @param chopit flag that determines whether chopping is executed or not      * @return String containg human readable signature      */
specifier|private
specifier|static
name|String
name|typeParamTypesToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
block|{
comment|// The first character is guranteed to be '<'
specifier|final
name|StringBuilder
name|typeParams
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"<"
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|1
decl_stmt|;
comment|// skip the '<'
comment|// get the first TypeParameter
name|typeParams
operator|.
name|append
argument_list|(
name|typeParamTypeToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
comment|// are there more TypeParameters?
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
literal|'>'
condition|)
block|{
name|typeParams
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|typeParams
operator|.
name|append
argument_list|(
name|typeParamTypeToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// account for the '>' char
return|return
name|typeParams
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts a type parameter signature to a string.      *      * @param signature signature to convert      * @param chopit flag that determines whether chopping is executed or not      * @return String containg human readable signature      */
specifier|private
specifier|static
name|String
name|typeParamTypeToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
block|{
name|int
name|index
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid type parameter signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
comment|// get the TypeParameter identifier
specifier|final
name|StringBuilder
name|typeParam
init|=
operator|new
name|StringBuilder
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|index
operator|++
expr_stmt|;
comment|// account for the ':'
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
literal|':'
condition|)
block|{
comment|// we have a class bound
name|typeParam
operator|.
name|append
argument_list|(
literal|" extends "
argument_list|)
expr_stmt|;
name|typeParam
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
comment|// look for interface bounds
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|index
operator|++
expr_stmt|;
comment|// skip over the ':'
name|typeParam
operator|.
name|append
argument_list|(
literal|"& "
argument_list|)
expr_stmt|;
name|typeParam
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|typeParam
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts a list of type signatures to a string.      *      * @param signature signature to convert      * @param chopit flag that determines whether chopping is executed or not      * @param term character indicating the end of the list      * @return String containg human readable signature      */
specifier|private
specifier|static
name|String
name|typeSignaturesToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|,
specifier|final
name|char
name|term
parameter_list|)
block|{
comment|// The first character will be an 'open' that matches the 'close' contained in term.
specifier|final
name|StringBuilder
name|typeList
init|=
operator|new
name|StringBuilder
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|1
decl_stmt|;
comment|// skip the 'open' character
comment|// get the first Type in the list
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
name|term
condition|)
block|{
name|typeList
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
comment|// are there more types in the list?
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
name|term
condition|)
block|{
name|typeList
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|typeList
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|+=
name|unwrap
argument_list|(
name|CONSUMER_CHARS
argument_list|)
expr_stmt|;
comment|// update position
block|}
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// account for the term char
return|return
name|typeList
operator|.
name|append
argument_list|(
name|term
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      *      * This method converts a type signature string into a Java type declaration such as 'String[]' and throws a      * 'ClassFormatException' when the parsed type is invalid.      *      * @param signature type signature      * @param chopit flag that determines whether chopping is executed or not      * @return string containing human readable type signature      * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file      * @since 6.4.0      */
specifier|public
specifier|static
name|String
name|typeSignatureToString
parameter_list|(
specifier|final
name|String
name|signature
parameter_list|,
specifier|final
name|boolean
name|chopit
parameter_list|)
throws|throws
name|ClassFormatException
block|{
comment|// corrected concurrent private static field acess
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// This is the default, read just one char like 'B'
try|try
block|{
switch|switch
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'B'
case|:
return|return
literal|"byte"
return|;
case|case
literal|'C'
case|:
return|return
literal|"char"
return|;
case|case
literal|'D'
case|:
return|return
literal|"double"
return|;
case|case
literal|'F'
case|:
return|return
literal|"float"
return|;
case|case
literal|'I'
case|:
return|return
literal|"int"
return|;
case|case
literal|'J'
case|:
return|return
literal|"long"
return|;
case|case
literal|'T'
case|:
block|{
comment|// TypeVariableSignature
specifier|final
name|int
name|index
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
comment|// Look for closing ';'
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid type variable signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
comment|// corrected concurrent private static field acess
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// "Tblabla;" 'T' and ';' are removed
return|return
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
return|;
block|}
case|case
literal|'L'
case|:
block|{
comment|// Full class name
comment|// should this be a while loop? can there be more than
comment|// one generic clause? (markro)
name|int
name|fromIndex
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|'<'
argument_list|)
decl_stmt|;
comment|// generic type?
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
name|fromIndex
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fromIndex
operator|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|'>'
argument_list|,
name|fromIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
block|}
specifier|final
name|int
name|index
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|,
name|fromIndex
argument_list|)
decl_stmt|;
comment|// Look for closing ';'
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
comment|// check to see if there are any TypeArguments
specifier|final
name|int
name|bracketIndex
init|=
name|signature
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|'<'
argument_list|)
decl_stmt|;
if|if
condition|(
name|bracketIndex
operator|<
literal|0
condition|)
block|{
comment|// just a class identifier
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// "Lblabla;" 'L' and ';' are removed
return|return
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
return|;
block|}
comment|// but make sure we are not looking past the end of the current item
name|fromIndex
operator|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
if|if
condition|(
name|fromIndex
operator|<
name|bracketIndex
condition|)
block|{
comment|// just a class identifier
name|wrap
argument_list|(
name|CONSUMER_CHARS
argument_list|,
name|fromIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// "Lblabla;" 'L' and ';' are removed
return|return
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|fromIndex
argument_list|)
argument_list|,
name|chopit
argument_list|)
return|;
block|}
comment|// we have TypeArguments; build up partial result
comment|// as we recurse for each TypeArgument
specifier|final
name|StringBuilder
name|type
init|=
operator|new
name|StringBuilder
argument_list|(
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|bracketIndex
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
decl_stmt|;
name|int
name|consumedChars
init|=
name|bracketIndex
operator|+
literal|1
decl_stmt|;
comment|// Shadows global var
comment|// check for wildcards
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'+'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|"? extends "
argument_list|)
expr_stmt|;
name|consumedChars
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|"? super "
argument_list|)
expr_stmt|;
name|consumedChars
operator|++
expr_stmt|;
block|}
comment|// get the first TypeArgument
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|consumedChars
operator|++
expr_stmt|;
block|}
else|else
block|{
name|type
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|consumedChars
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
comment|// update our consumed count by the number of characters the for type argument
name|consumedChars
operator|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|)
operator|+
name|consumedChars
expr_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|,
name|consumedChars
argument_list|)
expr_stmt|;
block|}
comment|// are there more TypeArguments?
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|!=
literal|'>'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
comment|// check for wildcards
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'+'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|"? extends "
argument_list|)
expr_stmt|;
name|consumedChars
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|"? super "
argument_list|)
expr_stmt|;
name|consumedChars
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'*'
condition|)
block|{
name|type
operator|.
name|append
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|consumedChars
operator|++
expr_stmt|;
block|}
else|else
block|{
name|type
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|consumedChars
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
comment|// update our consumed count by the number of characters the for type argument
name|consumedChars
operator|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|)
operator|+
name|consumedChars
expr_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|,
name|consumedChars
argument_list|)
expr_stmt|;
block|}
block|}
comment|// process the closing ">"
name|consumedChars
operator|++
expr_stmt|;
name|type
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|==
literal|'.'
condition|)
block|{
comment|// we have a ClassTypeSignatureSuffix
name|type
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
comment|// convert SimpleClassTypeSignature to fake ClassTypeSignature
comment|// and then recurse to parse it
name|type
operator|.
name|append
argument_list|(
name|typeSignatureToString
argument_list|(
literal|"L"
operator|+
name|signature
operator|.
name|substring
argument_list|(
name|consumedChars
operator|+
literal|1
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
comment|// update our consumed count by the number of characters the for type argument
comment|// note that this count includes the "L" we added, but that is ok
comment|// as it accounts for the "." we didn't consume
name|consumedChars
operator|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|)
operator|+
name|consumedChars
expr_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|,
name|consumedChars
argument_list|)
expr_stmt|;
return|return
name|type
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumedChars
argument_list|)
operator|!=
literal|';'
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
name|wrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|,
name|consumedChars
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// remove final ";"
return|return
name|type
operator|.
name|toString
argument_list|()
return|;
block|}
case|case
literal|'S'
case|:
return|return
literal|"short"
return|;
case|case
literal|'Z'
case|:
return|return
literal|"boolean"
return|;
case|case
literal|'['
case|:
block|{
comment|// Array declaration
name|int
name|n
decl_stmt|;
name|StringBuilder
name|brackets
decl_stmt|;
name|String
name|type
decl_stmt|;
name|int
name|consumedChars
decl_stmt|;
comment|// Shadows global var
name|brackets
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
comment|// Accumulate []'s
comment|// Count opening brackets and look for optional size argument
for|for
control|(
name|n
operator|=
literal|0
init|;
name|signature
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|==
literal|'['
condition|;
name|n
operator|++
control|)
block|{
name|brackets
operator|.
name|append
argument_list|(
literal|"[]"
argument_list|)
expr_stmt|;
block|}
name|consumedChars
operator|=
name|n
expr_stmt|;
comment|// Remember value
comment|// The rest of the string denotes a '<field_type>'
name|type
operator|=
name|typeSignatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|n
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
comment|// corrected concurrent private static field acess
comment|// Utility.consumed_chars += consumed_chars; is replaced by:
specifier|final
name|int
name|temp
init|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|)
operator|+
name|consumedChars
decl_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|CONSUMER_CHARS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|type
operator|+
name|brackets
operator|.
name|toString
argument_list|()
return|;
block|}
case|case
literal|'V'
case|:
return|return
literal|"void"
return|;
default|default:
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: '"
operator|+
name|signature
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|int
name|unwrap
parameter_list|(
specifier|final
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|tl
parameter_list|)
block|{
return|return
name|tl
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|wrap
parameter_list|(
specifier|final
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|tl
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
name|tl
operator|.
name|set
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

